ğŸ“‹ CÃ“DIGO DOS AGENTES - AUDITORIA COMPLETA
ğŸ“ Estrutura de Arquivos
src/agents/
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ agent_state.ts          # Estado base dos agentes
â”‚   â””â”€â”€ langgraph_agent.ts      # Classe base LangGraph
â”œâ”€â”€ harvey/
â”‚   â””â”€â”€ harvey_graph.ts         # Agente Harvey Specter
â”œâ”€â”€ justine/
â”‚   â””â”€â”€ justine_graph.ts        # Agente Mrs. Justine
â”œâ”€â”€ monitor-djen/
â”‚   â””â”€â”€ monitor_graph.ts        # Monitor DJEN
â”œâ”€â”€ analise-documental/
â”‚   â””â”€â”€ analise_documental_graph.ts
â”œâ”€â”€ analise-risco/
â”‚   â””â”€â”€ analise_risco_graph.ts
â”œâ”€â”€ compliance/
â”‚   â””â”€â”€ compliance_graph.ts
â”œâ”€â”€ comunicacao-clientes/
â”‚   â””â”€â”€ comunicacao_clientes_graph.ts
â”œâ”€â”€ estrategia-processual/
â”‚   â””â”€â”€ estrategia_processual_graph.ts
â”œâ”€â”€ financeiro/
â”‚   â””â”€â”€ financeiro_graph.ts
â”œâ”€â”€ gestao-prazos/
â”‚   â””â”€â”€ gestao_prazos_graph.ts
â”œâ”€â”€ organizacao-arquivos/
â”‚   â””â”€â”€ organizacao_arquivos_graph.ts
â”œâ”€â”€ pesquisa-juris/
â”‚   â””â”€â”€ pesquisa_graph.ts
â”œâ”€â”€ redacao-peticoes/
â”‚   â””â”€â”€ redacao_graph.ts
â”œâ”€â”€ revisao-contratual/
â”‚   â””â”€â”€ revisao_contratual_graph.ts
â””â”€â”€ traducao-juridica/
    â””â”€â”€ traducao_juridica_graph.ts
1ï¸âƒ£ BASE - Agent State (src/agents/base/agent_state.ts)
/**
 * Agent State Management
 *
 * This module defines the base state interface for LangGraph agents.
 * It provides type-safe state management for autonomous agents.
 *
 * Security Notes:
 * - No eval() or unsafe code execution
 * - Immutable state updates via spread operators
 * - Type-safe state transitions
 */
export interface AgentMessage {
  role: "system" | "user" | "assistant" | "tool";
  content: string;
  timestamp: number;
  metadata?: Record<string, unknown>;
}
export interface AgentState {
  messages: AgentMessage[];
  currentStep: string;
  data: Record<string, unknown>;
  error?: string;
  completed: boolean;
  retryCount: number;
  maxRetries: number;
  startedAt: number;
  lastUpdatedAt: number;
}
export const createInitialState = (data: Record<string, unknown> = {}): AgentState => ({
  messages: [],
  currentStep: "init",
  data,
  completed: false,
  retryCount: 0,
  maxRetries: 3,
  startedAt: Date.now(),
  lastUpdatedAt: Date.now(),
});
export const updateState = (state: AgentState, updates: Partial<AgentState>): AgentState => ({
  ...state,
  ...updates,
  lastUpdatedAt: Date.now(),
});
export const addMessage = (
  state: AgentState,
  message: Omit<AgentMessage, "timestamp">
): AgentState => ({
  ...state,
  messages: [
    ...state.messages,
    {
      ...message,
      timestamp: Date.now(),
    },
  ],
  lastUpdatedAt: Date.now(),
});
2ï¸âƒ£ BASE - LangGraph Agent (src/agents/base/langgraph_agent.ts)
/**
 * LangGraph Agent Base Class
 *
 * This module provides the base implementation for LangGraph-based agents.
 * It includes retry logic, timeout handling, and safe state management.
 *
 * Security Notes:
 * - Implements timeout protection to prevent hanging operations
 * - Automatic retry with exponential backoff
 * - No dynamic code execution (eval, Function constructor, etc.)
 * - All state mutations are immutable and type-safe
 *
 * Observability:
 * - Sentry AI Monitoring v2 integration
 * - OpenTelemetry semantic conventions
 * - Conversation tracking (sessionId, turn)
 */
import { createChatSpan } from "@/lib/sentry-gemini-integration-v2";
import type { AgentState } from "./agent_state";
import { addMessage, updateState } from "./agent_state";
export interface LangGraphConfig {
  timeoutMs: number;
  maxRetries: number;
  retryDelayMs: number;
  enableSentryTracing?: boolean;
  agentName?: string;
}
export const DEFAULT_CONFIG: LangGraphConfig = {
  timeoutMs: 30000,
  maxRetries: 3,
  retryDelayMs: 1000,
  enableSentryTracing: true,
  agentName: "unknown-agent",
};
export abstract class LangGraphAgent {
  protected config: LangGraphConfig;
  protected abortController: AbortController | null = null;
  protected sessionId: string;
  protected turnCounter: number = 0;
  constructor(config: Partial<LangGraphConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.sessionId = `${this.config.agentName}-${Date.now()}`;
  }
  async execute(state: AgentState): Promise<AgentState> {
    if (!this.config.enableSentryTracing) {
      return await this.executeInternal(state);
    }
    return await this.executeWithTracing(state);
  }
  private async executeWithTracing(state: AgentState): Promise<AgentState> {
    const messages = this.prepareMessages(state);
    try {
      const result = await createChatSpan<AgentState>(
        this.buildSpanConfig(),
        messages,
        async (span) => {
          this.addConversationTracking(span);
          const executedState = await this.executeInternal(state);
          this.addResponseTracking(span, executedState);
          this.addTokenTracking(span, executedState);
          this.turnCounter++;
          return executedState;
        }
      );
      return result;
    } catch (error) {
      return this.handleExecutionError(state, error);
    }
  }
  private async executeInternal(state: AgentState): Promise<AgentState> {
    let currentState = state;
    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {
      const result = await this.attemptExecution(currentState, attempt);
      if (result.success) {
        return result.state;
      }
      if (this.isLastAttempt(attempt)) {
        return result.state;
      }
      currentState = result.state;
      await this.applyBackoffDelay(attempt);
    }
    return currentState;
  }
  protected abstract run(state: AgentState, signal: AbortSignal): Promise<AgentState>;
  abort(): void {
    this.abortController?.abort();
  }
  protected addAgentMessage(
    state: AgentState,
    content: string,
    role: "assistant" | "tool" = "assistant"
  ): AgentState {
    return addMessage(state, { role, content });
  }
  getSessionId(): string {
    return this.sessionId;
  }
  getTurnCounter(): number {
    return this.turnCounter;
  }
}
3ï¸âƒ£ Harvey Specter (src/agents/harvey/harvey_graph.ts)
import Anthropic from "@anthropic-ai/sdk";
import type { AgentState } from "../base/agent_state";
import { updateState } from "../base/agent_state";
import { LangGraphAgent } from "../base/langgraph_agent";
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY || "",
});
export class HarveyAgent extends LangGraphAgent {
  protected async run(state: AgentState, signal: AbortSignal): Promise<AgentState> {
    let current = updateState(state, { currentStep: "harvey:start" });
    const task = (state.data.task as string) || "AnÃ¡lise estratÃ©gica geral do escritÃ³rio";
    try {
      const response = await anthropic.messages.create(
        {
          model: "claude-sonnet-4-20250514",
          max_tokens: 4096,
          system: `VocÃª Ã© Harvey Specter, estrategista jurÃ­dico sÃªnior.
RESPONSABILIDADES:
- Analisar estratÃ©gias jurÃ­dicas complexas
- Identificar riscos e oportunidades em processos
- Fornecer visÃ£o macro sobre casos jurÃ­dicos
- Sugerir tÃ¡ticas processuais eficazes
DIRETRIZES:
- Seja direto, confiante e objetivo
- Use terminologia jurÃ­dica precisa
- Cite legislaÃ§Ã£o quando relevante (CF/88, CPC/15, CC/02)
- Pense como um advogado de elite
- Responda SEMPRE em portuguÃªs brasileiro`,
          messages: [{ role: "user", content: task }],
        },
        { signal }
      );
      const result =
        response.content[0].type === "text"
          ? response.content[0].text
          : "Resposta nÃ£o textual recebida";
      current = updateState(current, {
        currentStep: "harvey:analysis_complete",
        data: { ...current.data, summary: result, usage: response.usage },
        completed: true,
      });
      return this.addAgentMessage(current, result);
    } catch (error) {
      console.error("[Harvey] Erro ao executar agente:", error);
      current = updateState(current, {
        currentStep: "harvey:error",
        data: { ...current.data, error: error instanceof Error ? error.message : "Erro desconhecido" },
        completed: false,
      });
      return this.addAgentMessage(current, "Erro ao processar anÃ¡lise estratÃ©gica.");
    }
  }
}
export async function runHarvey(data: Record<string, unknown> = {}): Promise<AgentState> {
  const agent = new HarveyAgent();
  const initialState: AgentState = {
    messages: [],
    currentStep: "init",
    data,
    completed: false,
    retryCount: 0,
    maxRetries: 3,
    startedAt: Date.now(),
    lastUpdatedAt: Date.now(),
  };
  return agent.execute(initialState);
}
4ï¸âƒ£ Mrs. Justine (src/agents/justine/justine_graph.ts)
import Anthropic from "@anthropic-ai/sdk";
import type { AgentState } from "../base/agent_state";
import { updateState } from "../base/agent_state";
import { LangGraphAgent } from "../base/langgraph_agent";
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY || "",
});
export class JustineAgent extends LangGraphAgent {
  protected async run(state: AgentState, signal: AbortSignal): Promise<AgentState> {
    let current = updateState(state, { currentStep: "justine:start" });
    const task = (state.data.task as string) || "Analisar intimaÃ§Ãµes e publicaÃ§Ãµes do DJEN";
    try {
      const response = await anthropic.messages.create(
        {
          model: "claude-sonnet-4-20250514",
          max_tokens: 4096,
          system: `VocÃª Ã© Mrs. Justine, assistente jurÃ­dica especialista em anÃ¡lise de intimaÃ§Ãµes e publicaÃ§Ãµes processuais.
RESPONSABILIDADES:
- Analisar intimaÃ§Ãµes do DiÃ¡rio de JustiÃ§a EletrÃ´nico (DJEN)
- Extrair informaÃ§Ãµes crÃ­ticas (prazos, decisÃµes, despachos)
- Identificar aÃ§Ãµes urgentes necessÃ¡rias
- Classificar prioridade das publicaÃ§Ãµes
- Detectar riscos de preclusÃ£o ou perda de prazo
DIRETRIZES:
- Seja precisa e detalhista na anÃ¡lise
- Destaque prazos peremptÃ³rios com urgÃªncia
- Cite artigos do CPC/15 relacionados aos prazos
- Use linguagem tÃ©cnica mas clara
- Sempre mencione a data limite para manifestaÃ§Ã£o
- Responda SEMPRE em portuguÃªs brasileiro`,
          messages: [{ role: "user", content: task }],
        },
        { signal }
      );
      const result =
        response.content[0].type === "text"
          ? response.content[0].text
          : "Resposta nÃ£o textual recebida";
      current = updateState(current, {
        currentStep: "justine:intimations_extracted",
        data: { ...current.data, analysis: result, found: 1, usage: response.usage },
        completed: true,
      });
      return this.addAgentMessage(current, result);
    } catch (error) {
      console.error("[Justine] Erro ao executar agente:", error);
      current = updateState(current, {
        currentStep: "justine:error",
        data: { ...current.data, error: error instanceof Error ? error.message : "Erro desconhecido" },
        completed: false,
      });
      return this.addAgentMessage(current, "Erro ao processar anÃ¡lise de intimaÃ§Ãµes.");
    }
  }
}
export async function runJustine(data: Record<string, unknown> = {}): Promise<AgentState> {
  const agent = new JustineAgent();
  const initialState: AgentState = {
    messages: [],
    currentStep: "init",
    data,
    completed: false,
    retryCount: 0,
    maxRetries: 3,
    startedAt: Date.now(),
    lastUpdatedAt: Date.now(),
  };
  return agent.execute(initialState);
}
5ï¸âƒ£ Monitor DJEN (src/agents/monitor-djen/monitor_graph.ts)
/**
 * DJEN Monitor LangGraph Agent
 *
 * This agent monitors the DJEN (DiÃ¡rio de JustiÃ§a EletrÃ´nico Nacional)
 * for new publications using a LangGraph workflow.
 *
 * Security Notes:
 * - Uses safe HTTP requests with timeout
 * - No eval() or dynamic code execution
 * - Validates all external data before processing
 */
import type { AgentState } from "../base/agent_state";
import { updateState } from "../base/agent_state";
import { LangGraphAgent } from "../base/langgraph_agent";
import { createInvokeAgentSpan } from "@/lib/sentry-gemini-integration-v2";
export interface DJENPublication {
  id: string;
  court: string;
  date: string;
  content: string;
  processNumber?: string;
}
export class DJENMonitorAgent extends LangGraphAgent {
  protected async run(state: AgentState, signal: AbortSignal): Promise<AgentState> {
    return createInvokeAgentSpan(
      { agentName: "Monitor DJEN", system: "custom-llm", model: "djen-api" },
      {
        sessionId: typeof state.data?.sessionId === "string"
          ? state.data.sessionId
          : `djen_session_${Date.now()}`,
        turn: state.retryCount + 1,
        messages: state.messages.map((m) => ({
          role: m.role as "user" | "assistant" | "system",
          content: m.content,
        })),
      },
      async (span) => {
        let currentState = updateState(state, { currentStep: "fetching_publications" });
        const startFetch = Date.now();
        const publications = await this.fetchPublications(signal);
        const fetchDuration = Date.now() - startFetch;
        span?.setAttribute("djen.publications_found", publications.length);
        span?.setAttribute("djen.fetch_duration_ms", fetchDuration);
        const criticalPublications = publications.filter((p) => p.processNumber);
        currentState = updateState(currentState, {
          currentStep: "completed",
          completed: true,
          data: { ...currentState.data, publications, criticalPublications, fetchDuration },
        });
        span?.setStatus({ code: 1, message: "ok" });
        return this.addAgentMessage(
          currentState,
          `Monitor DJEN concluÃ­do: ${publications.length} publicaÃ§Ãµes (${criticalPublications.length} crÃ­ticas) em ${fetchDuration}ms`
        );
      }
    );
  }
  private async fetchPublications(signal: AbortSignal): Promise<DJENPublication[]> {
    const { consultarDJEN } = await import("@/lib/djen-api");
    const today = new Date();
    const lastWeek = new Date(today);
    lastWeek.setDate(today.getDate() - 7);
    const results = await consultarDJEN({
      tribunais: ["TST", "TRT3", "TJMG"],
      searchTerms: {},
      dataInicio: lastWeek.toISOString().split("T")[0],
      dataFim: today.toISOString().split("T")[0],
      timeout: 30000,
    });
    if (signal.aborted) {
      throw new Error("Operation aborted");
    }
    return (results.resultados || [])
      .map((result: any, index: number) => ({
        id: `${result.tribunal}-${result.data}-${index}`,
        court: result.tribunal,
        date: result.data,
        content: result.teor || "",
        processNumber: result.numeroProcesso,
      }))
      .filter((p) => this.validatePublication(p));
  }
  private validatePublication(data: unknown): data is DJENPublication {
    if (typeof data !== "object" || data === null) return false;
    const pub = data as Record<string, unknown>;
    return (
      typeof pub.id === "string" &&
      typeof pub.court === "string" &&
      typeof pub.date === "string" &&
      typeof pub.content === "string"
    );
  }
}
export async function monitorDJEN(data: Record<string, unknown> = {}): Promise<AgentState> {
  const agent = new DJENMonitorAgent({ timeoutMs: 60000, maxRetries: 3 });
  const initialState: AgentState = {
    messages: [],
    currentStep: "init",
    data,
    completed: false,
    retryCount: 0,
    maxRetries: 3,
    startedAt: Date.now(),
    lastUpdatedAt: Date.now(),
  };
  return agent.execute(initialState);
}
6ï¸âƒ£ Demais Agentes (Resumo)
Os demais 10 agentes seguem a mesma estrutura base e estÃ£o disponÃ­veis nos arquivos:

Agente	Arquivo	FunÃ§Ã£o Principal
AnÃ¡lise Documental	analise_documental_graph.ts	Extrai entidades (partes, datas, valores) de documentos
AnÃ¡lise de Risco	analise_risco_graph.ts	Calcula score de risco processual (0-1)
Compliance	compliance_graph.ts	Verifica conformidade LGPD e detecta dados sensÃ­veis
ComunicaÃ§Ã£o Clientes	comunicacao_clientes_graph.ts	Gera comunicaÃ§Ãµes personalizadas para clientes
EstratÃ©gia Processual	estrategia_processual_graph.ts	Recomenda estratÃ©gias baseadas em fase e risco
Financeiro	financeiro_graph.ts	Analisa saÃºde financeira e gera KPIs
GestÃ£o de Prazos	gestao_prazos_graph.ts	Calcula prazos processuais e alertas
OrganizaÃ§Ã£o Arquivos	organizacao_arquivos_graph.ts	Categoriza documentos em pastas
Pesquisa Jurisprudencial	pesquisa_graph.ts	Busca precedentes em bases vetoriais
RedaÃ§Ã£o de PetiÃ§Ãµes	redacao_graph.ts	Gera rascunhos de petiÃ§Ãµes via Gemini
RevisÃ£o Contratual	revisao_contratual_graph.ts	Identifica clÃ¡usulas abusivas
TraduÃ§Ã£o JurÃ­dica	traducao_juridica_graph.ts	Traduz tÃ©cnicoâ†”simples
7ï¸âƒ£ Backend Routes (backend/src/routes/agents.ts)
import { Request, Response, Router } from "express";
import { dirname, resolve } from "path";
import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
let runHarvey: any;
let runJustine: any;
async function loadAgents() {
  try {
    const agentsPath = resolve(__dirname, "../../../src/agents");
    const harveyModule = await import(`${agentsPath}/harvey/harvey_graph.js`);
    runHarvey = harveyModule.runHarvey;
    const justineModule = await import(`${agentsPath}/justine/justine_graph.js`);
    runJustine = justineModule.runJustine;
    console.log("[Agents] âœ… Agentes reais carregados (Harvey + Justine)");
  } catch (error) {
    console.error("[Agents] âŒ Erro ao carregar agentes:", error);
    console.warn("[Agents] âš ï¸  Usando modo stub (IA desabilitada)");
  }
}
loadAgents();
const router = Router();
const HYBRID_AGENT_REGISTRY: Record<string, string> = {
  "harvey-specter": "langgraph-custom",
  "mrs-justine": "langgraph-custom",
  "monitor-djen": "langgraph-djen",
  "analise-documental": "langgraph-custom",
  "analise-risco": "langgraph-custom",
  compliance: "langgraph-custom",
  "comunicacao-clientes": "langgraph-custom",
  "estrategia-processual": "langgraph-custom",
  financeiro: "langgraph-custom",
  "gestao-prazos": "langgraph-custom",
  "organizacao-arquivos": "langgraph-custom",
  "pesquisa-juris": "langgraph-custom",
  "redacao-peticoes": "langgraph-custom",
  "revisao-contratual": "langgraph-custom",
  "traducao-juridica": "langgraph-custom",
};
router.get("/list", (_req: Request, res: Response) => {
  const agents = Object.entries(HYBRID_AGENT_REGISTRY).map(([id, type]) => ({
    agentId: id,
    type,
    status: "available",
  }));
  res.json({ success: true, agents, total: agents.length, timestamp: new Date().toISOString() });
});
router.post("/execute", async (req: Request, res: Response) => {
  const { agentId, task, config } = req.body;
  // ... execuÃ§Ã£o do agente
});
router.post("/orchestrate", async (req: Request, res: Response) => {
  const { agents, task, maxRounds = 5 } = req.body;
  // ... orquestraÃ§Ã£o multi-agente
});
export default router;
ğŸ“Š Resumo TÃ©cnico
Aspecto	Valor
Total de Agentes	15
Framework	LangGraph + TypeScript
LLM Principal	Anthropic Claude (claude-sonnet-4)
LLM SecundÃ¡rio	Google Gemini 2.5 Pro
Observabilidade	Sentry AI Monitoring + OpenTelemetry
Retry Policy	3 tentativas com backoff exponencial
Timeout	30 segundos (padrÃ£o), 60s (DJEN)
Estado	ImutÃ¡vel via spread operators
Todos os cÃ³digos estÃ£o copiados acima. Se precisar de algum arquivo adicional especÃ­fico, me avise!

Checkpoint made
Saved progress at the end of the loop
Worked for 2 minutes