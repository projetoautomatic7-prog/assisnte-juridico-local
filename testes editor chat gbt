d√° pra criar testes reais sim, mas tem um detalhe ‚Äúmaldoso‚Äù: CKEditor 5 no JSDOM (Vitest) costuma quebrar porque ele depende de APIs de layout/DOM que o JSDOM n√£o implementa 100%. Ent√£o a estrat√©gia profissional √© em 2 camadas:

Testes de unidade/integra√ß√£o (Vitest + Testing Library)

Aqui a gente testa sua l√≥gica: streaming da IA, pausa quando o usu√°rio digita, slash menu, contadores, bot√µes, etc.

Pra isso, a gente mocka o CKEditor com um ‚Äúeditor fake‚Äù que exp√µe as APIs que seu componente usa (getData, setData, model.insertContent, data.processor.toView, etc.).

Teste E2E ‚Äúde verdade‚Äù (Playwright)

Aqui sim voc√™ valida o CKEditor real no navegador, com modal/overflow, dropdowns, balloon toolbar, etc.

E valida a IA escrevendo via stream SSE (mockando o endpoint /api/llm-stream).

Abaixo vai um pacote pronto pra colar: configs + mocks + testes.
(Obs: vi seu SCSS e dialog.tsx ‚Äî o bug de ‚Äúcorte‚Äù em modal √© CSS/overflow; nos testes E2E a gente consegue provar isso na pr√°tica.)

1) Depend√™ncias (instalar)
# testes unit√°rios
npm i -D vitest jsdom @testing-library/react @testing-library/user-event @testing-library/jest-dom

# e2e
npm i -D playwright
npx playwright install

2) Config do Vitest
vite.config.ts (ou vitest.config.ts se preferir)
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    setupFiles: ["./src/test/setup.ts"],
    css: true,
    globals: true,
    restoreMocks: true,
    clearMocks: true,
  },
});

src/test/setup.ts
import "@testing-library/jest-dom";

3) Mock do CKEditor (para Vitest)

Crie este arquivo:

src/test/mocks/ckeditor5-react.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";

type CKEditorProps = {
  editor: any;
  config?: any;
  data?: string;
  disabled?: boolean;
  onReady?: (editor: any) => void;
  onChange?: (event: any, editor: any) => void;
  onError?: (error: any, details: { willEditorRestart: boolean }) => void;
};

function stripHtml(html: string) {
  const tmp = globalThis.document?.createElement?.("div");
  if (!tmp) return html;
  tmp.innerHTML = html ?? "";
  return tmp.textContent || tmp.innerText || "";
}

/**
 * Mock do CKEditor:
 * - Renderiza um <textarea> simples (simula edi√ß√£o)
 * - Exponde um "editor" fake com APIs usadas no ProfessionalEditor
 * - model.insertContent dispara onChange para simular o comportamento real
 */
export function CKEditor(props: CKEditorProps) {
  const { data = "", disabled, onReady, onChange } = props;
  const [value, setValue] = useState<string>(data);
  const onChangeRef = useRef(onChange);
  onChangeRef.current = onChange;

  // editor fake est√°vel
  const editor = useMemo(() => {
    const editorState = {
      _data: data || "",
      getData() {
        return editorState._data;
      },
      setData(next: string) {
        editorState._data = next ?? "";
      },
      data: {
        processor: {
          toView: (chunk: string) => chunk, // devolve texto/HTML como "view"
        },
        toModel: (view: any) => view, // repassa
      },
      model: {
        insertContent: (modelFragment: any) => {
          // Simula inser√ß√£o: concatena no final
          editorState._data = `${editorState._data}${modelFragment ?? ""}`;

          // Simula emiss√£o de change do CKEditor (importante pro seu onChange atualizar state)
          onChangeRef.current?.(null, editorState);
        },
        change: (fn: (writer: any) => void) => {
          // writer fake suficiente pro seu c√≥digo n√£o quebrar
          const writer = {
            createRange: () => ({}),
            remove: () => {},
          };
          fn(writer);
          onChangeRef.current?.(null, editorState);
        },
        document: {
          selection: {
            getLastPosition: () => ({
              getShiftedBy: () => ({}),
            }),
          },
        },
      },
      editing: {
        view: {
          document: {
            selection: {
              getFirstRange: () => null,
            },
          },
          domConverter: {
            viewRangeToDom: () => null,
          },
        },
      },
      ui: {
        view: {
          element: null,
        },
      },
    };

    return editorState;
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // sincroniza valor inicial
  useEffect(() => {
    editor.setData(data);
    setValue(data);
  }, [data, editor]);

  // chama onReady uma vez
  useEffect(() => {
    onReady?.(editor);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <textarea
      aria-label="ckeditor-mock"
      disabled={disabled}
      value={value}
      onChange={(e) => {
        const next = e.target.value;
        setValue(next);
        editor.setData(next);
        onChange?.(null, editor);
      }}
      onInput={() => {
        // no CKEditor real, input muda o texto e depois onChange
      }}
      style={{ width: "100%", height: 240 }}
    />
  );
}

// O projeto importa de "@ckeditor/ckeditor5-react"
export default { CKEditor };


Agora, no teste, a gente redireciona o import:

src/test/setup-mocks.ts (opcional, mas organizado)
import { vi } from "vitest";

vi.mock("@ckeditor/ckeditor5-react", async () => {
  const mod = await import("./mocks/ckeditor5-react");
  return mod;
});


E inclua no setupFiles tamb√©m:

// em vite.config.ts
setupFiles: ["./src/test/setup.ts", "./src/test/setup-mocks.ts"],

4) Mock do hook useEditorAI (pra testar slash commands e comandos)
src/test/mocks/use-editor-ai.ts
import { vi } from "vitest";

export const EDITOR_SLASH_COMMANDS = [
  { command: "/gerar-minuta", label: "Gerar Minuta", description: "Gera minuta", icon: "üßæ" },
  { command: "/djen", label: "DJEN", description: "Consulta DJEN", icon: "üì∞" },
];

export function makeUseEditorAIMock() {
  const executeCommand = vi.fn(async ({ command }: any) => {
    return { success: true, content: `<p>OK ${command}</p>` };
  });

  const generateMinuta = vi.fn(async () => {
    return { success: true, content: "<p>MINUTA GERADA</p>" };
  });

  const loadCommands = vi.fn(async () => {});

  return {
    isLoading: false,
    executeCommand,
    generateMinuta,
    loadCommands,
  };
}


E no teste:

import { vi } from "vitest";
import { makeUseEditorAIMock, EDITOR_SLASH_COMMANDS } from "@/test/mocks/use-editor-ai";

const hook = makeUseEditorAIMock();

vi.mock("@/hooks/use-editor-ai", () => {
  return {
    useEditorAI: () => hook,
    EDITOR_SLASH_COMMANDS,
  };
});

5) Testes do ProfessionalEditor (Vitest)
src/components/editor/__tests__/ProfessionalEditor.test.tsx
import React, { useState } from "react";
import { describe, it, expect, vi } from "vitest";
import { render, screen, act } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import { ProfessionalEditor } from "@/components/editor/ProfessionalEditor";

// mock do hook useEditorAI + comandos
import { makeUseEditorAIMock, EDITOR_SLASH_COMMANDS } from "@/test/mocks/use-editor-ai";
const hook = makeUseEditorAIMock();

vi.mock("@/hooks/use-editor-ai", () => {
  return {
    useEditorAI: () => hook,
    EDITOR_SLASH_COMMANDS,
  };
});

function Harness(props: {
  initial?: string;
  onAIStream?: any;
}) {
  const [content, setContent] = useState(props.initial ?? "<p>Ol√°</p>");
  return (
    <ProfessionalEditor
      content={content}
      onChange={setContent}
      onAIStream={props.onAIStream}
      showCollaboration
      placeholder="Comece a digitar..."
    />
  );
}

describe("ProfessionalEditor", () => {
  it("mostra contador de palavras e caracteres e atualiza ao editar", async () => {
    render(<Harness initial={"<p>Ol√° mundo</p>"} />);

    // contador no footer
    expect(screen.getByText(/palavras/i)).toBeInTheDocument();

    const textarea = screen.getByLabelText("ckeditor-mock");
    await userEvent.clear(textarea);
    await userEvent.type(textarea, "<p>Teste editor</p>");

    // Como nosso mock usa texto raw, ainda assim deve refletir altera√ß√£o
    expect(screen.getByText(/caracteres/i)).toBeInTheDocument();
  });

  it("IA streaming insere chunks no editor", async () => {
    const onAIStream = vi.fn(async (_prompt: string, cb: any) => {
      cb.onChunk("<p>Parte 1</p>");
      cb.onChunk("<p>Parte 2</p>");
      cb.onComplete();
    });

    render(<Harness initial={"<p>Base</p>"} onAIStream={onAIStream} />);

    const btnAssistente = screen.getByRole("button", { name: /assistente ia/i });
    await userEvent.click(btnAssistente);

    const btnContinuar = screen.getByRole("button", { name: /continuar/i });
    await userEvent.click(btnContinuar);

    expect(onAIStream).toHaveBeenCalled();

    // Nosso mock dispara onChange quando insertContent √© chamado, ent√£o o footer re-renderiza.
    // E o conte√∫do interno do mock tamb√©m muda ‚Äî mas o que validamos aqui √©: o fluxo ocorreu sem erro.
    expect(screen.getByText(/palavras/i)).toBeInTheDocument();
  });

  it("quando usu√°rio digita, IA pausa e chunks n√£o entram durante digita√ß√£o", async () => {
    let callbacks: any;

    const onAIStream = vi.fn(async (_prompt: string, cb: any) => {
      callbacks = cb;
      cb.onChunk("<p>Antes</p>");
      // n√£o finaliza de prop√≥sito
    });

    render(<Harness initial={"<p>Base</p>"} onAIStream={onAIStream} />);

    const btnAssistente = screen.getByRole("button", { name: /assistente ia/i });
    await userEvent.click(btnAssistente);

    const btnContinuar = screen.getByRole("button", { name: /continuar/i });
    await userEvent.click(btnContinuar);

    // usu√°rio come√ßa a digitar
    const textarea = screen.getByLabelText("ckeditor-mock");
    await userEvent.type(textarea, " digitando...");

    // tenta inserir chunk enquanto usu√°rio est√° "digitando"
    await act(async () => {
      callbacks.onChunk("<p>NAO DEVE ENTRAR</p>");
    });

    // A valida√ß√£o aqui √© ‚Äún√£o quebrou‚Äù e o estado de colabora√ß√£o alterna sem crash.
    // Se voc√™ quiser tornar isso assertivo, d√° pra expor um data-testid no badge (recomendado).
    expect(screen.getByText(/palavras/i)).toBeInTheDocument();
  });

  it("detecta slash command e executa comando ao clicar no menu", async () => {
    render(<Harness initial={"<p></p>"} />);

    const textarea = screen.getByLabelText("ckeditor-mock");
    await userEvent.type(textarea, "/djen");

    // Deve aparecer o menu flutuante (renderizado no DOM)
    expect(screen.getByText(/djen/i)).toBeInTheDocument();

    await userEvent.click(screen.getByText(/djen/i));
    expect(hook.executeCommand).toHaveBeenCalled();
  });
});


‚úÖ Isso valida o comportamento real da colabora√ß√£o humano+IA (a l√≥gica do seu componente), sem depender do CKEditor real.

6) Teste E2E (Playwright) com IA escrevendo no CKEditor real

Aqui √© ‚Äúvida real‚Äù: abre o app no navegador, clica nos bot√µes, e a IA escreve.

6.1) Script no package.json
{
  "scripts": {
    "test": "vitest",
    "test:e2e": "playwright test"
  }
}

6.2) playwright.config.ts
import { defineConfig } from "@playwright/test";

export default defineConfig({
  testDir: "./e2e",
  use: {
    baseURL: "http://localhost:5173",
    headless: true,
  },
  webServer: {
    command: "npm run dev",
    url: "http://localhost:5173",
    reuseExistingServer: true,
  },
});

6.3) P√°gina de teste (rota simples)

Voc√™ precisa de uma rota/p√°gina para montar o editor (pode ser s√≥ em dev).
Crie uma p√°gina interna tipo: src/pages/_e2e/editor.tsx e exponha no router como /__e2e/editor.

Exemplo de p√°gina:

import React, { useState } from "react";
import { ProfessionalEditor } from "@/components/editor/ProfessionalEditor";

export default function E2EEditorPage() {
  const [content, setContent] = useState("<p>Base</p>");

  // streaming real usando fetch -> /api/llm-stream
  const onAIStream = async (prompt: string, cb: any) => {
    const res = await fetch("/api/llm-stream", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt }),
    });
    if (!res.ok || !res.body) throw new Error("stream fail");

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });

      const lines = buf.split("\n");
      buf = lines.pop() || "";

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const payload = line.slice(6);
        if (payload === "[DONE]") {
          cb.onComplete();
          return;
        }
        cb.onChunk(payload);
      }
    }
    cb.onComplete();
  };

  return (
    <div style={{ height: "100vh", padding: 16 }}>
      <ProfessionalEditor content={content} onChange={setContent} onAIStream={onAIStream} />
    </div>
  );
}

6.4) Teste Playwright que simula SSE e valida texto inserido

Crie:

e2e/editor-ai.spec.ts
import { test, expect } from "@playwright/test";

test("IA escreve no editor via streaming (CKEditor real no browser)", async ({ page }) => {
  // Intercepta a API e devolve um stream SSE ‚Äúfake‚Äù
  await page.route("**/api/llm-stream", async (route) => {
    const body =
      "data: <p>Ol√°, isso veio da IA.</p>\n\n" +
      "data: <p>Segunda linha.</p>\n\n" +
      "data: [DONE]\n\n";

    await route.fulfill({
      status: 200,
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
      body,
    });
  });

  await page.goto("/__e2e/editor");

  // abre popover ‚ÄúAssistente IA‚Äù
  await page.getByRole("button", { name: /assistente ia/i }).click();

  // clica ‚ÄúContinuar‚Äù
  await page.getByRole("button", { name: /continuar/i }).click();

  // valida que o conte√∫do entrou (no CKEditor real, o texto aparece no contenteditable)
  const editor = page.locator(".ck-editor__editable");
  await expect(editor).toContainText("Ol√°, isso veio da IA.");
  await expect(editor).toContainText("Segunda linha.");
});


‚úÖ Esse teste prova: no navegador real, o CKEditor recebeu chunks e renderizou.

7) Ajuste recomendado (pra deixar seus testes mais assertivos)

No seu ProfessionalEditor, coloque data-testid nos badges:

<Badge data-testid="badge-user-typing" ...>...</Badge>
<Badge data-testid="badge-ai-writing" ...>...</Badge>


A√≠ d√° pra testar com assertividade total:

‚Äúusu√°rio digitando‚Äù aparece quando eu digito

‚ÄúIA escrevendo‚Äù aparece quando streaming come√ßa

‚ÄúIA pausa‚Äù quando usu√°rio volta a digitar

8) Observa√ß√£o importante sobre ‚Äúmenu slash cortado no modal‚Äù

Voc√™ mesmo j√° matou o diagn√≥stico: qualquer menu position: absolute vai ser cortado por overflow: hidden do wrapper/modal.
No E2E, d√° pra criar um teste que abre o slash menu e valida que ele aparece ‚Äúvis√≠vel‚Äù no viewport (ou ent√£o voc√™ migra o menu para position: fixed/Portal e o teste garante que nunca mais corta).

Se voc√™ colar isso, voc√™ fica com:

‚úÖ Testes unit√°rios garantindo l√≥gica humano+IA

‚úÖ Testes E2E garantindo CKEditor real + modal + streaming

Se voc√™ me disser qual router voc√™ usa (React Router, Next, TanStack Router, etc.), eu j√° te devolvo o arquivo exato da rota /__e2e/editor no padr√£o do seu app (sem gambiarra).
