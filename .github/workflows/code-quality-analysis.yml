name: AnÃ¡lise de CÃ³digo e Qualidade

on:
  # Removido: push trigger - CI.yml jÃ¡ faz lint e verificaÃ§Ãµes bÃ¡sicas
  # Rodar apenas em PRs e sob demanda
  pull_request:
    branches: [main, develop]
  schedule:
    # Executar semanalmente nas segundas Ã s 6h UTC
    - cron: "0 6 * * 1"
  workflow_dispatch:
    inputs:
      analysis_type:
        description: "Tipo de anÃ¡lise"
        required: false
        default: "full"
        type: choice
        options:
          - full
          - lint-only
          - complexity-only
          - coverage-only
          - security-only
      fail_on_warnings:
        description: "Falhar em warnings"
        required: false
        default: false
        type: boolean

concurrency:
  group: code-analysis-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ==========================================
  # ğŸ” ANÃLISE ESTÃTICA E LINTING
  # ==========================================

  static-analysis:
    name: "ğŸ” AnÃ¡lise EstÃ¡tica e Linting"
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.analysis_type == 'full' || github.event.inputs.analysis_type == 'lint-only'
    env:
      NODE_OPTIONS: --max-old-space-size=8192

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"
          cache-dependency-path: package-lock.json

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-quality-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-quality-

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ” Executar ESLint
        env:
          FAIL_ON_WARNINGS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.fail_on_warnings || 'false' }}
        run: |
          echo "ğŸ” Executando ESLint..."
          EXIT_CODE=0

          # Executar ESLint com formato legÃ­vel e capturar exit code
          npm run lint -- --max-warnings 350 || EXIT_CODE=$?

          if [[ $EXIT_CODE -eq 0 ]]; then
            echo "âœ… ESLint passou sem erros ou warnings"
          else
            # FAIL_ON_WARNINGS Ã© passado como env var do workflow
            if [[ "${FAIL_ON_WARNINGS:-false}" == "true" ]]; then
              echo "âŒ ESLint falhou (treating warnings as failure)"
              exit $EXIT_CODE
            else
              echo "âš ï¸  ESLint encontrou warnings/errors, mas continuando (fail_on_warnings=false)"
              # NÃ£o sair com erro - permitir continuaÃ§Ã£o
            fi
          fi

      - name: ğŸ“Š Executar TypeScript Check
        run: |
          echo "ğŸ“Š Executando verificaÃ§Ã£o TypeScript..."

          # Executar verificaÃ§Ã£o de tipos
          npx tsc --noEmit --pretty

          if [[ $? -eq 0 ]]; then
            echo "âœ… TypeScript check passou"
          else
            echo "âŒ TypeScript check falhou"
            exit 1
          fi

      - name: ğŸ—ï¸  Executar Build de ProduÃ§Ã£o
        run: |
          echo "ğŸ—ï¸  Executando build de produÃ§Ã£o..."

          npm run build

          if [[ $? -eq 0 ]]; then
            echo "âœ… Build de produÃ§Ã£o passou"
            BUILD_SIZE=$(du -sh dist/ | cut -f1)
            echo "ğŸ“¦ Tamanho do build: $BUILD_SIZE"
          else
            echo "âŒ Build de produÃ§Ã£o falhou"
            exit 1
          fi

      - name: ğŸ“¤ Upload Resultados ESLint
        uses: actions/upload-artifact@v4.4.3
        with:
          name: eslint-results
          path: eslint-results.sarif

      - name: ğŸ“Š Upload RelatÃ³rio SARIF para GitHub
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: eslint-results.sarif
          category: eslint

      - name: Generate TypeScript SARIF report
        run: npm run tsc:sarif || true
        continue-on-error: true

      - name: Upload TypeScript SARIF to GitHub
        if: always() && hashFiles('tsc-results.sarif') != ''
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: tsc-results.sarif
          category: typescript
        continue-on-error: true

  # ==========================================
  # ğŸ§© ANÃLISE DE COMPLEXIDADE
  # ==========================================

  complexity-analysis:
    name: "ğŸ§© AnÃ¡lise de Complexidade"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.analysis_type == 'full' || github.event.inputs.analysis_type == 'complexity-only'
    env:
      NODE_OPTIONS: --max-old-space-size=8192

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ§© AnÃ¡lise de Complexidade CiclomÃ¡tica
        run: |
          echo "ğŸ§© Analisando complexidade ciclomÃ¡tica..."

          # Instalar eslint-plugin-complexity se nÃ£o estiver instalado
          npm install --save-dev eslint-plugin-complexity

          # Executar anÃ¡lise de complexidade
          npx eslint src/ \
            --plugin complexity \
            --rule 'complexity: [error, 10]' \
            --format json \
            --output-file complexity-results.json || true

          # Processar resultados
          if [[ -f complexity-results.json ]]; then
            HIGH_COMPLEXITY=$(jq '[.[] | select(.messages[]?.ruleId == "complexity")] | length' complexity-results.json)
            echo "ğŸ”„ FunÃ§Ãµes com alta complexidade: $HIGH_COMPLEXITY"

            if [[ $HIGH_COMPLEXITY -gt 0 ]]; then
              echo "âš ï¸  ALERTA: $HIGH_COMPLEXITY funÃ§Ãµes com complexidade > 10"
              jq -r '.[] | select(.messages[]?.ruleId == "complexity") | "\(.filePath):\(.messages[] | select(.ruleId == "complexity") | .line):\(.messages[] | select(.ruleId == "complexity") | .message)"' complexity-results.json > high-complexity-functions.txt
            fi
          fi

      - name: ğŸ“Š AnÃ¡lise de Manutenibilidade
        run: |
          echo "ğŸ“Š Analisando manutenibilidade..."

          # Usar jscpd para detectar cÃ³digo duplicado
          npx jscpd src/ \
            --format json \
            --output duplicates.json \
            --min-lines 10 \
            --min-tokens 50 || true

          if [[ -f duplicates.json ]]; then
            DUPLICATE_PERCENTAGE=$(jq '.statistics.total.percentage' duplicates.json 2>/dev/null || echo "0")
            echo "ğŸ“‹ Percentual de cÃ³digo duplicado: $DUPLICATE_PERCENTAGE%"

            if (( $(echo "$DUPLICATE_PERCENTAGE > 5" | bc -l) )); then
              echo "âš ï¸  ALERTA: Alto percentual de cÃ³digo duplicado ($DUPLICATE_PERCENTAGE%)"
            fi
          fi

      - name: ğŸ“ AnÃ¡lise de Tamanho de Arquivos
        run: |
          echo "ğŸ“ Analisando tamanho de arquivos..."

          # Analisar arquivos grandes
          find src/ -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" | xargs wc -l | sort -nr | head -10 > large-files.txt

          echo "ğŸ“Š Top 10 arquivos por linhas:" >> file-size-report.md
          cat large-files.txt >> file-size-report.md

          # Verificar arquivos muito grandes
          LARGE_FILES=$(find src/ -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -exec wc -l {} \; | awk '$1 > 500 {print $2}' | wc -l)

          if [[ $LARGE_FILES -gt 0 ]]; then
            echo "âš ï¸  ALERTA: $LARGE_FILES arquivos com mais de 500 linhas"
          fi

      - name: ğŸ“¤ Upload RelatÃ³rios de Complexidade
        uses: actions/upload-artifact@v4.4.3
        with:
          name: complexity-reports
          path: |
            complexity-results.json
            duplicates.json
            high-complexity-functions.txt
            file-size-report.md

  # ==========================================
  # ğŸ§ª COBERTURA DE TESTES
  # ==========================================

  test-coverage:
    name: "ğŸ§ª Cobertura de Testes"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.analysis_type == 'full' || github.event.inputs.analysis_type == 'coverage-only'
    env:
      NODE_OPTIONS: --max-old-space-size=8192

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ§ª Executar Testes com Cobertura
        run: |
          echo "ğŸ§ª Executando testes com cobertura..."

          # Executar testes com cobertura usando Vitest
          npm run test -- --coverage --reporter=json --outputFile=coverage-results.json

          # Verificar se testes passaram
          if [[ $? -eq 0 ]]; then
            echo "âœ… Testes passaram"
          else
            echo "âŒ Testes falharam"
            exit 1
          fi

      - name: ğŸ“Š Analisar Cobertura
        run: |
          echo "ğŸ“Š Analisando cobertura de testes..."

          # Extrair mÃ©tricas de cobertura
          if [[ -f coverage/coverage-summary.json ]]; then
            LINES_COVERAGE=$(jq '.total.lines.pct' coverage/coverage-summary.json)
            FUNCTIONS_COVERAGE=$(jq '.total.functions.pct' coverage/coverage-summary.json)
            BRANCHES_COVERAGE=$(jq '.total.branches.pct' coverage/coverage-summary.json)
            STATEMENTS_COVERAGE=$(jq '.total.statements.pct' coverage/coverage-summary.json)

            echo "ğŸ“ˆ Cobertura de linhas: $LINES_COVERAGE%"
            echo "ğŸ“Š Cobertura de funÃ§Ãµes: $FUNCTIONS_COVERAGE%"
            echo "ğŸŒ¿ Cobertura de branches: $BRANCHES_COVERAGE%"
            echo "ğŸ“ Cobertura de statements: $STATEMENTS_COVERAGE%"

            # Verificar thresholds mÃ­nimos
            MIN_COVERAGE=80

            if (( $(echo "$LINES_COVERAGE < $MIN_COVERAGE" | bc -l) )); then
              echo "âŒ ALERTA: Cobertura de linhas baixa ($LINES_COVERAGE% < $MIN_COVERAGE%)"
              exit 1
            fi

            if (( $(echo "$FUNCTIONS_COVERAGE < $MIN_COVERAGE" | bc -l) )); then
              echo "âŒ ALERTA: Cobertura de funÃ§Ãµes baixa ($FUNCTIONS_COVERAGE% < $MIN_COVERAGE%)"
              exit 1
            fi

            # Salvar mÃ©tricas para relatÃ³rio
            {
              echo "lines_coverage: $LINES_COVERAGE"
              echo "functions_coverage: $FUNCTIONS_COVERAGE"
              echo "branches_coverage: $BRANCHES_COVERAGE"
              echo "statements_coverage: $STATEMENTS_COVERAGE"
              echo "threshold: $MIN_COVERAGE"
            } > coverage-metrics.json

          else
            echo "âš ï¸  Arquivo de cobertura nÃ£o encontrado"
          fi

      - name: ğŸ“¤ Upload RelatÃ³rios de Cobertura
        uses: actions/upload-artifact@v4.4.3
        with:
          name: coverage-reports
          path: |
            coverage/
            coverage-metrics.json

      - name: ğŸ’¯ Publicar Cobertura no PR
        if: github.event_name == 'pull_request'
        run: |
          echo "ğŸ’¯ Publicando cobertura no PR..."

          # Criar comentÃ¡rio no PR com cobertura
          if [[ -f coverage-metrics.json ]]; then
            LINES=$(jq -r '.lines_coverage' coverage-metrics.json)
            FUNCTIONS=$(jq -r '.functions_coverage' coverage-metrics.json)
            BRANCHES=$(jq -r '.branches_coverage' coverage-metrics.json)

            echo "## ğŸ§ª Cobertura de Testes" > coverage-comment.md
            echo "" >> coverage-comment.md
            echo "- **Linhas:** $LINES%" >> coverage-comment.md
            echo "- **FunÃ§Ãµes:** $FUNCTIONS%" >> coverage-comment.md
            echo "- **Branches:** $BRANCHES%" >> coverage-comment.md
            echo "" >> coverage-comment.md

            # Verificar cobertura de linhas
            LOW_LINES=$(echo "$LINES < 80" | bc -l)
            if [ "$LOW_LINES" -eq 1 ]; then
              echo "âš ï¸  Cobertura de linhas abaixo do threshold (80%)" >> coverage-comment.md
            fi

            # Verificar cobertura de funÃ§Ãµes
            LOW_FUNCTIONS=$(echo "$FUNCTIONS < 80" | bc -l)
            if [ "$LOW_FUNCTIONS" -eq 1 ]; then
              echo "âš ï¸  Cobertura de funÃ§Ãµes abaixo do threshold (80%)" >> coverage-comment.md
            fi

            gh pr comment ${{ github.event_name == 'pull_request' && github.event.number || github.sha }} --body-file coverage-comment.md
          fi
        env:
          GH_TOKEN: ${{ github.token }}

  # ==========================================
  # ğŸ”’ ANÃLISE DE SEGURANÃ‡A
  # ==========================================

  security-analysis:
    name: "ğŸ”’ AnÃ¡lise de SeguranÃ§a"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.analysis_type == 'full' || github.event.inputs.analysis_type == 'security-only'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ” Executar Audit de SeguranÃ§a
        run: |
          echo "ğŸ” Executando audit de seguranÃ§a..."

          # Executar npm audit, mas nÃ£o permitir que o audit cause exit do script diretamente.
          # NÃ³s interpretaremos o JSON e falharemos explicitamente se houver vulnerabilidades crÃ­ticas.
          npm audit --audit-level moderate --json > security-audit.json || true

          # Garantir que exista um JSON legÃ­vel (ou inicializar valores a 0)
          if [[ ! -s security-audit.json ]]; then
            echo "âš ï¸ npm audit nÃ£o retornou dados vÃ¡lidos, criando arquivo vazio"
            echo '{"metadata":{"vulnerabilities":{"total":0,"critical":0,"high":0,"moderate":0}}}' > security-audit.json
          fi

          # Analisar resultados
          VULNERABILITIES=$(jq '.metadata.vulnerabilities.total' security-audit.json 2>/dev/null || echo "0")
          CRITICAL=$(jq '.metadata.vulnerabilities.critical' security-audit.json 2>/dev/null || echo "0")
          HIGH=$(jq '.metadata.vulnerabilities.high' security-audit.json 2>/dev/null || echo "0")
          MODERATE=$(jq '.metadata.vulnerabilities.moderate' security-audit.json 2>/dev/null || echo "0")

          echo "ğŸš¨ Vulnerabilidades totais: $VULNERABILITIES"
          echo "ğŸ”´ CrÃ­ticas: $CRITICAL"
          echo "ğŸŸ  Altas: $HIGH"
          echo "ğŸŸ¡ Moderadas: $MODERATE"

          if [[ $CRITICAL -gt 0 ]]; then
            echo "âŒ ALERTA CRÃTICO: Vulnerabilidades crÃ­ticas encontradas!"
            exit 1
          fi

          if [[ $HIGH -gt 0 ]]; then
            echo "âš ï¸  ALERTA: Vulnerabilidades altas encontradas"
          fi

      - name: ğŸ›¡ï¸  VerificaÃ§Ã£o de DependÃªncias
        run: |
          echo "ğŸ›¡ï¸  Verificando dependÃªncias desatualizadas..."

          # Verificar dependÃªncias desatualizadas
          npm outdated --json > outdated-dependencies.json || true

          OUTDATED_COUNT=$(jq 'length' outdated-dependencies.json 2>/dev/null || echo "0")
          echo "ğŸ“¦ DependÃªncias desatualizadas: $OUTDATED_COUNT"

          if [[ $OUTDATED_COUNT -gt 10 ]]; then
            echo "âš ï¸  ALERTA: Muitas dependÃªncias desatualizadas ($OUTDATED_COUNT)"
          fi

      - name: ğŸ” VerificaÃ§Ã£o de Segredos
        run: |
          echo "ğŸ” Verificando exposiÃ§Ã£o de segredos..."

          # Usar git-secrets ou similar para verificar commits
          # Aqui vocÃª pode integrar ferramentas como:
          # - git-secrets
          # - trufflehog
          # - gitleaks

          echo "ğŸ” VerificaÃ§Ã£o de segredos concluÃ­da"

      - name: ğŸ“¤ Upload RelatÃ³rios de SeguranÃ§a
        uses: actions/upload-artifact@v4.4.3
        with:
          name: security-reports
          path: |
            security-audit.json
            outdated-dependencies.json

  # ==========================================
  # ğŸ“Š DASHBOARD DE QUALIDADE
  # ==========================================

  quality-dashboard:
    name: "ğŸ“Š Dashboard de Qualidade"
    runs-on: ubuntu-latest
    needs: [static-analysis, complexity-analysis, test-coverage, security-analysis]
    if: always()

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ“Š Gerar RelatÃ³rio Consolidado de Qualidade
        run: |
          echo "ğŸ“Š Gerando relatÃ³rio consolidado de qualidade..."

          # Criar relatÃ³rio markdown
          {
            echo "# ğŸ“Š RelatÃ³rio de Qualidade de CÃ³digo"
            echo ""
            echo "**Commit:** ${{ github.sha }}"
            echo "**Branch:** ${{ github.ref }}"
            echo "**Data:** $(date)"
            echo ""
            echo "## ğŸ” Status das AnÃ¡lises"
            echo ""
            echo "| AnÃ¡lise | Status | Detalhes |"
            echo "|---------|--------|----------|"
            echo "| AnÃ¡lise EstÃ¡tica | ${{ needs.static-analysis.result }} | Linting + TypeScript |"
            echo "| Complexidade | ${{ needs.complexity-analysis.result }} | CiclomÃ¡tica + DuplicaÃ§Ã£o |"
            echo "| Cobertura | ${{ needs.test-coverage.result }} | Testes unitÃ¡rios |"
            echo "| SeguranÃ§a | ${{ needs.security-analysis.result }} | Vulnerabilidades + DependÃªncias |"
            echo ""
          } > quality-report.md

          # Determinar status geral
          if [[ "${{ needs.static-analysis.result }}" == "success" && \
                "${{ needs.complexity-analysis.result }}" == "success" && \
                "${{ needs.test-coverage.result }}" == "success" && \
                "${{ needs.security-analysis.result }}" == "success" ]]; then
            echo "## âœ… STATUS GERAL: TODAS AS ANÃLISES PASSARAM" >> quality-report.md
            echo "STATUS=success" >> $GITHUB_ENV
          else
            echo "## âŒ STATUS GERAL: PROBLEMAS DETECTADOS" >> quality-report.md
            echo "STATUS=failure" >> $GITHUB_ENV
          fi

          # Adicionar mÃ©tricas se disponÃ­veis
          if [[ -f coverage-metrics.json ]]; then
            LINES=$(jq -r '.lines_coverage' coverage-metrics.json 2>/dev/null || echo "N/A")
            FUNCTIONS=$(jq -r '.functions_coverage' coverage-metrics.json 2>/dev/null || echo "N/A")
            echo "" >> quality-report.md
            echo "## ğŸ§ª MÃ©tricas de Cobertura" >> quality-report.md
            echo "- **Linhas:** $LINES%" >> quality-report.md
            echo "- **FunÃ§Ãµes:** $FUNCTIONS%" >> quality-report.md
          fi

          echo "" >> quality-report.md
          echo "## ğŸ“‹ RecomendaÃ§Ãµes" >> quality-report.md
          echo "" >> quality-report.md

          # Adicionar recomendaÃ§Ãµes baseadas nos resultados
          if [[ "${{ needs.complexity-analysis.result }}" != "success" ]]; then
            echo "- ğŸ”„ **Refatorar funÃ§Ãµes complexas** - Reduzir complexidade ciclomÃ¡tica" >> quality-report.md
          fi

          if [[ "${{ needs.test-coverage.result }}" != "success" ]]; then
            echo "- ğŸ§ª **Aumentar cobertura de testes** - Adicionar mais testes unitÃ¡rios" >> quality-report.md
          fi

          if [[ "${{ needs.security-analysis.result }}" != "success" ]]; then
            echo "- ğŸ”’ **Atualizar dependÃªncias** - Corrigir vulnerabilidades de seguranÃ§a" >> quality-report.md
          fi

          echo "" >> quality-report.md
          echo "*RelatÃ³rio gerado automaticamente*" >> quality-report.md

      - name: ğŸ“¤ Upload Dashboard de Qualidade
        uses: actions/upload-artifact@v4.4.3
        with:
          name: quality-dashboard
          path: quality-report.md

      - name: ğŸ’¬ Comentar no PR
        if: github.event_name == 'pull_request' && env.STATUS == 'failure'
        run: |
          echo "ğŸ’¬ Comentando qualidade no PR..."

          # Comentar no PR sobre problemas de qualidade
          echo "## âš ï¸ Problemas de Qualidade Detectados" > quality-alert.md
          echo "" >> quality-alert.md
          echo "Algumas verificaÃ§Ãµes de qualidade falharam. Verifique os artefatos do workflow para detalhes:" >> quality-alert.md
          echo "" >> quality-alert.md
          echo "- ğŸ” **AnÃ¡lise EstÃ¡tica:** ${{ needs.static-analysis.result }}" >> quality-alert.md
          echo "- ğŸ§© **Complexidade:** ${{ needs.complexity-analysis.result }}" >> quality-alert.md
          echo "- ğŸ§ª **Cobertura:** ${{ needs.test-coverage.result }}" >> quality-alert.md
          echo "- ğŸ”’ **SeguranÃ§a:** ${{ needs.security-analysis.result }}" >> quality-alert.md
          echo "" >> quality-alert.md
          echo "**AÃ§Ãµes recomendadas:**" >> quality-alert.md
          echo "1. Revisar os relatÃ³rios de anÃ¡lise nos artefatos" >> quality-alert.md
          echo "2. Corrigir problemas crÃ­ticos antes do merge" >> quality-alert.md
          echo "3. Considerar refatoraÃ§Ã£o para melhorar a qualidade" >> quality-alert.md

          gh pr comment ${{ github.event_name == 'pull_request' && github.event.number || github.sha }} --body-file quality-alert.md
        env:
          GH_TOKEN: ${{ github.token }}

      - name: ğŸš« Bloquear Merge se Qualidade Baixa
        if: github.event_name == 'pull_request' && env.STATUS == 'failure'
        run: |
          echo "ğŸš« Qualidade insuficiente - merge bloqueado"

          # Aqui vocÃª pode implementar lÃ³gica para bloquear merge
          # usando branch protection rules ou labels

  # ==========================================
  # ğŸ“¢ NOTIFICAÃ‡Ã•ES DE QUALIDADE
  # ==========================================

  quality-notifications:
    name: "ğŸ“¢ NotificaÃ§Ãµes de Qualidade"
    runs-on: ubuntu-latest
    needs: quality-dashboard
    if: always()

    steps:
      - name: ğŸ“¢ Preparar NotificaÃ§Ãµes de Qualidade
        run: |
          echo "ğŸ“¢ Preparando notificaÃ§Ãµes de qualidade..."

          # Criar notificaÃ§Ã£o baseada no status
          if [[ "${{ env.STATUS }}" == "success" ]]; then
            TITLE="âœ… Qualidade de CÃ³digo Aprovada"
            MESSAGE="Todas as verificaÃ§Ãµes de qualidade passaram com sucesso."
            PRIORITY="normal"
          else
            TITLE="âŒ Problemas de Qualidade Detectados"
            MESSAGE="Algumas verificaÃ§Ãµes de qualidade falharam. Verifique os relatÃ³rios."
            PRIORITY="high"
          fi

          # Criar payload de notificaÃ§Ã£o
          {
            echo "title: \"$TITLE\""
            echo "message: \"$MESSAGE\""
            echo "priority: \"$PRIORITY\""
            echo "timestamp: \"$(date -Iseconds)\""
            echo "commit: \"${{ github.sha }}\""
            echo "branch: \"${{ github.ref }}\""
          } > quality-notification.json

      - name: ğŸ’¬ Slack Notification
        run: |
          echo "ğŸ’¬ Enviando notificaÃ§Ã£o para Slack..."
          # Implementar webhook do Slack com o payload

      - name: ğŸ“§ Email Notification
        run: |
          echo "ğŸ“§ Enviando notificaÃ§Ã£o por email..."
          # Implementar serviÃ§o de email

      - name: ğŸ“± Teams Notification
        run: |
          echo "ğŸ“± Enviando notificaÃ§Ã£o para Teams..."
          # Implementar webhook do Teams

      - name: ğŸ“¤ Upload NotificaÃ§Ãµes
        uses: actions/upload-artifact@v4.4.3
        with:
          name: quality-notifications
          path: quality-notification.json
