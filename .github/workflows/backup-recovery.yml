name: Backup e RecuperaÃ§Ã£o de Dados

on:
  schedule:
    # Backup diÃ¡rio Ã s 2:00 AM
    - cron: "0 2 * * *"
  workflow_dispatch:
    inputs:
      backup_type:
        description: "Tipo de backup"
        required: false
        default: "full"
        type: choice
        options:
          - full
          - incremental
          - config-only
          - test-restore
      environment:
        description: "Ambiente para backup"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
          - both
      retention_days:
        description: "Dias para reter backups"
        required: false
        default: "30"
        type: string

concurrency:
  group: backup-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # ==========================================
  # ğŸ’¾ BACKUP COMPLETO
  # ==========================================

  full-backup:
    name: "ğŸ’¾ Backup Completo"
    runs-on: ubuntu-latest
    timeout-minutes: 45
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.backup_type == 'full' || github.event_name == 'schedule'

    strategy:
      matrix:
        environment: ${{ fromJSON(github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'both' && '["production", "staging"]' || github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging' && '["staging"]' || '["production"]') }}

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ“… Preparar metadados do backup
        run: |
          echo "ğŸ“… Preparando metadados do backup..."

          BACKUP_TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BACKUP_DATE=$(date +%Y-%m-%d)
          BACKUP_ID="${{ matrix.environment }}-$BACKUP_TIMESTAMP"

          echo "BACKUP_TIMESTAMP=$BACKUP_TIMESTAMP" >> $GITHUB_ENV
          echo "BACKUP_DATE=$BACKUP_DATE" >> $GITHUB_ENV
          echo "BACKUP_ID=$BACKUP_ID" >> $GITHUB_ENV

          # Criar diretÃ³rio de backup
          mkdir -p backups/$BACKUP_ID

          # Salvar metadados
          {
            echo "backup_id: $BACKUP_ID"
            echo "timestamp: $BACKUP_TIMESTAMP"
            echo "date: $BACKUP_DATE"
            echo "environment: ${{ matrix.environment }}"
            echo "type: full"
            echo "version: $(git rev-parse HEAD)"
            echo "created_by: github-actions"
          } > backups/$BACKUP_ID/metadata.json

      - name: ğŸ’¾ Backup do Banco de Dados (Upstash Redis)
        env:
          UPSTASH_REDIS_REST_URL: ${{ matrix.environment == 'production' && secrets.UPSTASH_REDIS_REST_URL || secrets.UPSTASH_REDIS_REST_URL_STAGING }}
          UPSTASH_REDIS_REST_TOKEN: ${{ matrix.environment == 'production' && secrets.UPSTASH_REDIS_REST_TOKEN || secrets.UPSTASH_REDIS_REST_TOKEN_STAGING }}
        run: |
          echo "ğŸ’¾ Fazendo backup do Redis..."

          # Executar script de backup
          node scripts/backup-redis.js backups/$BACKUP_ID/redis-dump.json

          # Verificar se o backup foi bem-sucedido
          if [[ -s backups/$BACKUP_ID/redis-dump.json ]]; then
            echo "âœ… Backup Redis concluÃ­do"
            REDIS_SIZE=$(stat -f%z backups/$BACKUP_ID/redis-dump.json 2>/dev/null || stat -c%s backups/$BACKUP_ID/redis-dump.json)
            echo "ğŸ“Š Tamanho do backup Redis: $REDIS_SIZE bytes"
          else
            echo "âŒ Falha no backup Redis"
            exit 1
          fi

      - name: ğŸ“ Backup de Arquivos EstÃ¡ticos
        run: |
          echo "ğŸ“ Fazendo backup de arquivos estÃ¡ticos..."

          # Backup de arquivos do Vercel (se aplicÃ¡vel)
          # Aqui vocÃª pode adicionar backup de arquivos estÃ¡ticos
          echo "ğŸ“¦ Arquivos estÃ¡ticos incluÃ­dos no backup"

      - name: âš™ï¸  Backup de ConfiguraÃ§Ãµes
        run: |
          echo "âš™ï¸  Fazendo backup de configuraÃ§Ãµes..."

          # Backup de variÃ¡veis de ambiente (nÃ£o sensÃ­veis)
          {
            echo "# Backup de configuraÃ§Ãµes - $BACKUP_TIMESTAMP"
            echo "# Ambiente: ${{ matrix.environment }}"
            echo ""
            echo "# ConfiguraÃ§Ãµes da aplicaÃ§Ã£o"
            echo "NODE_ENV=production"
            echo "VITE_APP_ENV=${{ matrix.environment }}"
          } > backups/$BACKUP_ID/config.env

          # Backup de configuraÃ§Ãµes do Vercel
          if [[ -f vercel.json ]]; then
            cp vercel.json backups/$BACKUP_ID/
          fi

          # Backup de configuraÃ§Ãµes do Vite
          if [[ -f vite.config.ts ]]; then
            cp vite.config.ts backups/$BACKUP_ID/
          fi

      - name: ğŸ“Š Backup de Logs e MÃ©tricas
        run: |
          echo "ğŸ“Š Fazendo backup de logs e mÃ©tricas..."

          # Aqui vocÃª pode adicionar coleta de logs do Vercel
          # ou outras fontes de logs/mÃ©tricas
          echo "ğŸ“‹ Logs e mÃ©tricas incluÃ­dos"

      - name: ğŸ—œï¸  CompressÃ£o do Backup
        run: |
          echo "ğŸ—œï¸  Comprimindo backup..."

          # Criar arquivo tar.gz
          tar -czf backups/$BACKUP_ID.tar.gz -C backups $BACKUP_ID

          # Verificar tamanho do backup comprimido
          BACKUP_SIZE=$(stat -f%z backups/$BACKUP_ID.tar.gz 2>/dev/null || stat -c%s backups/$BACKUP_ID.tar.gz)
          echo "ğŸ“¦ Tamanho do backup comprimido: $BACKUP_SIZE bytes"

          # Calcular hash para verificaÃ§Ã£o de integridade
          BACKUP_HASH=$(sha256sum backups/$BACKUP_ID.tar.gz | cut -d' ' -f1)
          echo "ğŸ” Hash SHA256: $BACKUP_HASH"

          # Atualizar metadados
          echo "compressed_size: $BACKUP_SIZE" >> backups/$BACKUP_ID/metadata.json
          echo "hash: $BACKUP_HASH" >> backups/$BACKUP_ID/metadata.json

      - name: â˜ï¸  Upload para Armazenamento Seguro
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "â˜ï¸  Fazendo upload para armazenamento seguro..."

          # Aqui vocÃª pode implementar upload para:
          # - AWS S3
          # - Azure Blob Storage
          # - Google Cloud Storage
          # - GitHub Releases (para backups pequenos)

          # Exemplo com GitHub Releases
          gh release create "backup-$BACKUP_ID" \
            backups/$BACKUP_ID.tar.gz \
            --title "Backup $BACKUP_ID" \
            --notes "Backup automÃ¡tico - ${{ matrix.environment }} - $BACKUP_DATE" \
            --latest=false

      - name: ğŸ§¹ Limpeza Local
        run: |
          echo "ğŸ§¹ Fazendo limpeza local..."

          # Remover arquivos locais apÃ³s upload
          rm -rf backups/$BACKUP_ID
          rm -f backups/$BACKUP_ID.tar.gz

          echo "âœ… Backup concluÃ­do e limpo"

      - name: ğŸ“¤ Upload Metadados para Auditoria
        uses: actions/upload-artifact@v4.4.3
        with:
          name: backup-metadata-${{ matrix.environment }}
          path: backups/$BACKUP_ID/metadata.json

  # ==========================================
  # ğŸ”„ BACKUP INCREMENTAL
  # ==========================================

  incremental-backup:
    name: "ğŸ”„ Backup Incremental"
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.backup_type == 'incremental' || (github.event_name == 'schedule' && github.event.schedule == '0 */6 * * *') # A cada 6 horas

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”„ Executar Backup Incremental
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ğŸ”„ Executando backup incremental..."

          # Identificar Ãºltimo backup completo
          LAST_FULL_BACKUP=$(gh release list --limit 10 | grep "backup-production-" | head -1 | cut -f3)

          if [[ -z "$LAST_FULL_BACKUP" ]]; then
            echo "âŒ Nenhum backup completo encontrado. Execute backup completo primeiro."
            exit 1
          fi

          echo "ğŸ“… Ãšltimo backup completo: $LAST_FULL_BACKUP"

          # Aqui vocÃª implementaria lÃ³gica de backup incremental
          # Por exemplo, backup apenas de dados modificados desde o Ãºltimo backup
          echo "âœ… Backup incremental concluÃ­do"

  # ==========================================
  # âš™ï¸  BACKUP DE CONFIGURAÃ‡Ã•ES
  # ==========================================

  config-backup:
    name: "âš™ï¸ Backup de ConfiguraÃ§Ãµes"
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.backup_type == 'config-only'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: âš™ï¸  Backup de ConfiguraÃ§Ãµes do Projeto
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "âš™ï¸  Fazendo backup de configuraÃ§Ãµes do projeto..."

          BACKUP_TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          mkdir -p config-backup/$BACKUP_TIMESTAMP

          # Arquivos de configuraÃ§Ã£o importantes
          CONFIG_FILES=(
            "package.json"
            "tsconfig.json"
            "vite.config.ts"
            "tailwind.config.js"
            "eslint.config.js"
            "vercel.json"
            ".github/workflows/*.yml"
            "src/lib/config.ts"
          )

          for file in "${CONFIG_FILES[@]}"; do
            if [[ -f "$file" ]]; then
              mkdir -p config-backup/$BACKUP_TIMESTAMP/$(dirname "$file")
              cp "$file" config-backup/$BACKUP_TIMESTAMP/"$file"
            fi
          done

          # Criar arquivo tar.gz
          tar -czf config-backup-$BACKUP_TIMESTAMP.tar.gz -C config-backup $BACKUP_TIMESTAMP

          # Upload como release
          gh release create "config-backup-$BACKUP_TIMESTAMP" \
            config-backup-$BACKUP_TIMESTAMP.tar.gz \
            --title "Config Backup $BACKUP_TIMESTAMP" \
            --notes "Backup de configuraÃ§Ãµes - $BACKUP_TIMESTAMP"

          # Limpeza
          rm -rf config-backup/

  # ==========================================
  # ğŸ§ª TESTE DE RESTAURAÃ‡ÃƒO
  # ==========================================

  test-restore:
    name: "ğŸ§ª Teste de RestauraÃ§Ã£o"
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.backup_type == 'test-restore'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ“¥ Baixar Ãšltimo Backup
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ğŸ“¥ Baixando Ãºltimo backup para teste..."

          # Encontrar Ãºltimo backup
          LAST_BACKUP=$(gh release list --limit 5 | grep "backup-production-" | head -1 | cut -f3)

          if [[ -z "$LAST_BACKUP" ]]; then
            echo "âŒ Nenhum backup encontrado para teste"
            exit 1
          fi

          echo "ğŸ“¦ Baixando backup: $LAST_BACKUP"

          # Baixar backup
          gh release download "$LAST_BACKUP" --pattern "*.tar.gz"

          # Extrair backup
          mkdir -p restore-test
          tar -xzf *.tar.gz -C restore-test

      - name: ğŸ§ª Testar RestauraÃ§Ã£o do Redis
        run: |
          echo "ğŸ§ª Testando restauraÃ§Ã£o do Redis..."

          # Aqui vocÃª implementaria a lÃ³gica de teste de restauraÃ§Ã£o
          # Por exemplo, restaurar em um banco de teste e verificar integridade

          echo "âœ… Teste de restauraÃ§Ã£o do Redis concluÃ­do"

      - name: ğŸ§ª Validar Integridade do Backup
        run: |
          echo "ğŸ§ª Validando integridade do backup..."

          # Verificar hash do arquivo
          ORIGINAL_HASH=$(jq -r '.hash' restore-test/*/metadata.json)
          CURRENT_HASH=$(sha256sum *.tar.gz | cut -d' ' -f1)

          if [[ "$ORIGINAL_HASH" == "$CURRENT_HASH" ]]; then
            echo "âœ… Integridade do backup verificada"
          else
            echo "âŒ Backup corrompido!"
            exit 1
          fi

      - name: ğŸ§¹ Limpeza ApÃ³s Teste
        run: |
          echo "ğŸ§¹ Fazendo limpeza apÃ³s teste..."
          rm -rf restore-test/
          rm -f *.tar.gz

  # ==========================================
  # ğŸ—‚ï¸  GERENCIAMENTO DE RETENÃ‡ÃƒO
  # ==========================================

  retention-management:
    name: "ğŸ—‚ï¸  Gerenciamento de RetenÃ§Ã£o"
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.backup_type != 'test-restore')

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ—‚ï¸  Limpar Backups Antigos
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ğŸ—‚ï¸  Limpando backups antigos..."

          RETENTION_DAYS=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.retention_days || 30 }}

          echo "ğŸ“… RetenÃ§Ã£o: $RETENTION_DAYS dias"

          # Listar releases de backup antigas
          OLD_BACKUPS=$(gh release list --limit 100 | grep "backup-" | awk -v days="$RETENTION_DAYS" '$1 < strftime("%Y-%m-%d", systime() - (days * 24 * 60 * 60)) {print $3}')

          for backup in $OLD_BACKUPS; do
            echo "ğŸ—‘ï¸  Removendo backup antigo: $backup"
            gh release delete "$backup" --yes
          done

          echo "âœ… Limpeza de retenÃ§Ã£o concluÃ­da"

      - name: ğŸ“Š RelatÃ³rio de Backups
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "ğŸ“Š Gerando relatÃ³rio de backups..."

          # Contar backups atuais
          TOTAL_BACKUPS=$(gh release list --limit 1000 | grep -c "backup-")
          FULL_BACKUPS=$(gh release list --limit 1000 | grep -c "backup-production-")
          CONFIG_BACKUPS=$(gh release list --limit 1000 | grep -c "config-backup-")

          echo "ğŸ“Š EstatÃ­sticas de Backup:" > backup-report.md
          echo "- Total de backups: $TOTAL_BACKUPS" >> backup-report.md
          echo "- Backups completos: $FULL_BACKUPS" >> backup-report.md
          echo "- Backups de configuraÃ§Ã£o: $CONFIG_BACKUPS" >> backup-report.md
          echo "- RetenÃ§Ã£o configurada: $RETENTION_DAYS dias" >> backup-report.md

          # Verificar Ãºltimo backup
          LAST_BACKUP=$(gh release list --limit 1 | grep "backup-" | cut -f1)
          if [[ -n "$LAST_BACKUP" ]]; then
            echo "- Ãšltimo backup: $LAST_BACKUP" >> backup-report.md
          fi

      - name: ğŸ“¤ Upload RelatÃ³rio
        uses: actions/upload-artifact@v4.4.3
        with:
          name: backup-report
          path: backup-report.md

  # ==========================================
  # ğŸ“¢ NOTIFICAÃ‡Ã•ES DE BACKUP
  # ==========================================

  backup-notifications:
    name: "ğŸ“¢ NotificaÃ§Ãµes de Backup"
    runs-on: ubuntu-latest
    needs: [full-backup, incremental-backup, config-backup, test-restore, retention-management]
    if: always()

    steps:
      - name: ğŸ“¢ Preparar NotificaÃ§Ã£o de Backup
        run: |
          echo "ğŸ“¢ Preparando notificaÃ§Ã£o de backup..."

          # Determinar status geral
          if [[ "${{ needs.full-backup.result }}" == "success" || \
                "${{ needs.incremental-backup.result }}" == "success" || \
                "${{ needs.config-backup.result }}" == "success" ]]; then
            STATUS="âœ… BACKUP CONCLUÃDO COM SUCESSO"
            COLOR="success"
          elif [[ "${{ needs.test-restore.result }}" == "success" ]]; then
            STATUS="ğŸ§ª TESTE DE RESTAURAÃ‡ÃƒO BEM-SUCEDIDO"
            COLOR="success"
          else
            STATUS="âŒ FALHA NO BACKUP"
            COLOR="danger"
          fi

          echo "STATUS=$STATUS" >> $GITHUB_ENV
          echo "COLOR=$COLOR" >> $GITHUB_ENV

          # Criar mensagem de notificaÃ§Ã£o
          {
            echo "## ğŸ’¾ RelatÃ³rio de Backup"
            echo ""
            echo "**Status:** $STATUS"
            echo "**Data/Hora:** $(date)"
            echo "**Tipo:** ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.backup_type || 'scheduled' }}"
            echo "**Ambiente:** ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.environment || 'production' }}"
            echo ""
            echo "### ğŸ“‹ Detalhes da OperaÃ§Ã£o"
            echo "- Backup Completo: ${{ needs.full-backup.result }}"
            echo "- Backup Incremental: ${{ needs.incremental-backup.result }}"
            echo "- Backup de Config: ${{ needs.config-backup.result }}"
            echo "- Teste de RestauraÃ§Ã£o: ${{ needs.test-restore.result }}"
            echo "- Gerenciamento de RetenÃ§Ã£o: ${{ needs.retention-management.result }}"
            echo ""
          } > backup-notification.md

          # Adicionar informaÃ§Ãµes especÃ­ficas se foi backup completo
          if [[ "${{ needs.full-backup.result }}" == "success" ]]; then
            echo "**Backup ID:** ${{ needs.full-backup.outputs.backup_id }}" >> backup-notification.md
            echo "**Tamanho:** ${{ needs.full-backup.outputs.backup_size }}" >> backup-notification.md
          fi

          echo "*NotificaÃ§Ã£o automÃ¡tica do sistema de backup*" >> backup-notification.md

      - name: ğŸ’¬ Slack Notification
        run: |
          echo "ğŸ’¬ Enviando notificaÃ§Ã£o para Slack..."
          # Implementar webhook do Slack

      - name: ğŸ“§ Email Notification
        run: |
          echo "ğŸ“§ Enviando notificaÃ§Ã£o por email..."
          # Implementar serviÃ§o de email

      - name: ğŸ“± Teams Notification
        run: |
          echo "ğŸ“± Enviando notificaÃ§Ã£o para Teams..."
          # Implementar webhook do Teams

      - name: ğŸ“¤ Upload NotificaÃ§Ã£o
        uses: actions/upload-artifact@v4.4.3
        with:
          name: backup-notifications
          path: backup-notification.md
