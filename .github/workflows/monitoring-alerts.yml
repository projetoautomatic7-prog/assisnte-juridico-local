name: Monitoramento ContÃ­nuo e Alertas

on:
  schedule:
    # Executar 2x ao dia (6h e 18h UTC) - suficiente para monitoramento
    - cron: "0 6,18 * * *"
  workflow_dispatch:
    inputs:
      check_type:
        description: "Tipo de verificaÃ§Ã£o"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - health
          - performance
          - security
          - dependencies
      environment:
        description: "Ambiente para verificar"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
          - both

concurrency:
  group: monitoring-${{ github.ref }}
  # NÃ£o cancelar execuÃ§Ãµes em andamento para workflows de monitoramento
  # Cada execuÃ§Ã£o agendada deve completar para garantir alertas
  cancel-in-progress: false

# Timeout global para evitar execuÃ§Ãµes longas
env:
  WORKFLOW_TIMEOUT: 10

jobs:
  # ==========================================
  # ğŸ¥ VERIFICAÃ‡ÃƒO DE SAÃšDE
  # ==========================================

  health-check:
    name: "ğŸ¥ VerificaÃ§Ã£o de SaÃºde"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'health' || github.event_name == 'schedule'

    strategy:
      matrix:
        environment: ${{ github.event_name != 'workflow_dispatch' && fromJSON('["production"]') || fromJSON(github.event.inputs.environment == 'both' && '["production", "staging"]' || github.event.inputs.environment == 'staging' && '["staging"]' || '["production"]') }}

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ¥ Health Check BÃ¡sico
        run: |
          echo "ğŸ¥ Executando health check bÃ¡sico..."

          # Prefer explicit environment overrides; fallback to default publicly-known URL
          if [[ -n "${{ secrets.PRODUCTION_URL }}" ]] && [[ "${{ matrix.environment }}" == "production" ]]; then
            APP_URL="${{ secrets.PRODUCTION_URL }}"
          elif [[ -n "${{ secrets.STAGING_URL }}" ]] && [[ "${{ matrix.environment }}" == "staging" ]]; then
            APP_URL="${{ secrets.STAGING_URL }}"
          else
            if [[ "${{ matrix.environment }}" == "production" ]]; then
              APP_URL="https://assistente-juridico-github.vercel.app"
            else
              APP_URL="https://assistente-juridico-github-staging.vercel.app"
            fi
          fi

          echo "ğŸŒ Verificando: $APP_URL"

          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL" || echo "000")
          echo "HTTP_STATUS=$HTTP_STATUS"

          if [[ "$HTTP_STATUS" -ne 200 ]]; then
            echo "âš ï¸  HTTP Status: $HTTP_STATUS for $APP_URL"
            # Do NOT mask errors. Export status so subsequent jobs can decide what to do.
          else
            echo "âœ… HTTP Status: $HTTP_STATUS"
          fi

          # Verificar tempo de resposta apenas se o site estiver acessÃ­vel
          if [[ "$HTTP_STATUS" -eq 200 ]]; then
            RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$APP_URL" 2>/dev/null || echo "0.0")
            echo "â±ï¸  Tempo de resposta: ${RESPONSE_TIME}s"

            if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
              echo "âš ï¸  Tempo de resposta alto: ${RESPONSE_TIME}s"
            fi
          else
            RESPONSE_TIME="0.0"
          fi

          # Exportar para prÃ³ximos steps
          echo "HTTP_STATUS=$HTTP_STATUS" >> $GITHUB_ENV
          echo "RESPONSE_TIME=$RESPONSE_TIME" >> $GITHUB_ENV
          echo "APP_URL=$APP_URL" >> $GITHUB_ENV

      - name: ğŸ” VerificaÃ§Ã£o de APIs CrÃ­ticas
        run: |
          echo "ğŸ” Verificando APIs crÃ­ticas..."

          # URL base do app
          BASE_URL="https://assistente-juridico-github.vercel.app"

          # Lista de endpoints crÃ­ticos para verificar
          ENDPOINTS=(
            "/api/status"
            "/api/kv"
            "/api/agents"
            "/api/expedientes"
            "/api/legal-services"
          )

          for endpoint in "${ENDPOINTS[@]}"; do
            FULL_URL="$BASE_URL$endpoint"
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$FULL_URL" || echo "000")

            if [[ "$STATUS" -eq 200 ]] || [[ "$STATUS" -eq 401 ]] || [[ "$STATUS" -eq 405 ]]; then
              echo "âœ… $endpoint: OK (Status: $STATUS)"
            else
              echo "âš ï¸  $endpoint: $STATUS (endpoint pode estar indisponÃ­vel)"
            fi
          done

      - name: ğŸ’¾ VerificaÃ§Ã£o de Banco de Dados
        run: |
          echo "ğŸ’¾ Verificando conectividade do banco..."

          # Aqui vocÃª pode adicionar verificaÃ§Ãµes especÃ­ficas do seu banco
          # Por exemplo, verificar se Upstash Redis responde
          if [[ -n "${{ secrets.UPSTASH_REDIS_REST_URL }}" ]]; then
            REDIS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.UPSTASH_REDIS_REST_URL }}/ping")
            if [[ "$REDIS_STATUS" -eq 200 ]]; then
              echo "âœ… Redis: OK"
            else
              echo "âŒ Redis: $REDIS_STATUS"
            fi
          fi

      - name: ğŸ“Š Coletar MÃ©tricas de SaÃºde
        run: |
          echo "ğŸ“Š Coletando mÃ©tricas de saÃºde..."

          # Salvar mÃ©tricas em arquivo para upload
          {
            echo "timestamp: $(date -Iseconds)"
            echo "environment: ${{ matrix.environment }}"
            echo "http_status: $HTTP_STATUS"
            echo "response_time: $RESPONSE_TIME"
            echo "uptime_check: true"
          } > health-metrics.json

      - name: ğŸ“¤ Upload MÃ©tricas de SaÃºde
        uses: actions/upload-artifact@v4.4.3
        with:
          name: health-metrics-${{ matrix.environment }}
          path: health-metrics.json

  # ==========================================
  # ğŸ“ˆ MONITORAMENTO DE PERFORMANCE
  # ==========================================

  performance-monitoring:
    name: "ğŸ“ˆ Monitoramento de Performance"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'performance' || github.event_name == 'schedule'
    needs: health-check

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸƒ Lighthouse Performance Audit
        run: |
          echo "ğŸƒ Executando Lighthouse performance audit..."

          # Ensure TARGET_URL can be overridden
          TARGET_URL="${{ secrets.PRODUCTION_URL }}"
          if [[ -z "$TARGET_URL" ]]; then
            TARGET_URL="https://assistente-juridico-github.vercel.app"
          fi

          echo "ğŸ¯ Target URL: $TARGET_URL"

          # Check status before running Lighthouse
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 20 "$TARGET_URL" || echo "000")
          echo "Checking TARGET_URL: $TARGET_URL -> HTTP $HTTP_STATUS"

          if [[ "$HTTP_STATUS" -ne 200 ]]; then
            echo "âŒ Skipping Lighthouse because target is not reachable (HTTP $HTTP_STATUS)"
            # Create a minimal report so the step has artifacts to inspect
            jq -n --arg url "$TARGET_URL" --arg status "$HTTP_STATUS" '{error: "target_not_reachable", target: $url, http_status: $status}' > lighthouse-report.json || echo '{"error":"target_not_reachable"}' > lighthouse-report.json
            echo "performance_score: 0" > performance-metrics.json
            echo "accessibility_score: 0" >> performance-metrics.json
            echo "best_practices_score: 0" >> performance-metrics.json
            echo "seo_score: 0" >> performance-metrics.json
            echo "timestamp: $(date -Iseconds)" >> performance-metrics.json
            echo "âš ï¸  Lighthouse skipped - site not reachable"
            exit 0
          fi

          # Try up to 3 times in case of intermittent failures
          TRIES=0
          MAX_TRIES=3
          while [[ $TRIES -lt $MAX_TRIES ]]; do
            TRIES=$((TRIES + 1))
            echo "Running Lighthouse attempt $TRIES/$MAX_TRIES..."
            npx lighthouse "$TARGET_URL" \
              --output=json \
              --output-path=./lighthouse-report.json \
              --only-categories=performance,accessibility,best-practices,seo \
              --chrome-flags="--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --single-process" && break || {
                echo "Lighthouse attempt $TRIES failed."
                sleep 3
              }
          done

          if [[ ! -f lighthouse-report.json ]]; then
            echo "âŒ Lighthouse did not produce a report after $MAX_TRIES attempts."
            jq -n '{error: "lighthouse_failed"}' > lighthouse-report.json || echo '{"error":"lighthouse_failed"}' > lighthouse-report.json
            echo "performance_score: 0" > performance-metrics.json
            echo "accessibility_score: 0" >> performance-metrics.json
            echo "best_practices_score: 0" >> performance-metrics.json
            echo "seo_score: 0" >> performance-metrics.json
            echo "timestamp: $(date -Iseconds)" >> performance-metrics.json
            # allow workflow to continue so monitoring-dashboard aggregates results
            exit 0
          fi

          # Extract metrics (existing logic)
          PERFORMANCE_SCORE=$(jq '.categories.performance.score * 100' lighthouse-report.json 2>/dev/null || echo "0")
          ACCESSIBILITY_SCORE=$(jq '.categories.accessibility.score * 100' lighthouse-report.json 2>/dev/null || echo "0")
          BEST_PRACTICES_SCORE=$(jq '.categories."best-practices".score * 100' lighthouse-report.json 2>/dev/null || echo "0")
          SEO_SCORE=$(jq '.categories.seo.score * 100' lighthouse-report.json 2>/dev/null || echo "0")

          echo "ğŸ“Š Performance Score: $PERFORMANCE_SCORE"
          echo "â™¿ Accessibility Score: $ACCESSIBILITY_SCORE"
          echo "âœ¨ Best Practices Score: $BEST_PRACTICES_SCORE"
          echo "ğŸ” SEO Score: $SEO_SCORE"

          # Alertar se performance estiver baixa
          if (( $(echo "$PERFORMANCE_SCORE < 80" | bc -l 2>/dev/null || echo "0") )); then
            echo "âš ï¸  ALERTA: Performance score baixo ($PERFORMANCE_SCORE)"
          fi

          # Salvar mÃ©tricas
          {
            echo "timestamp: $(date -Iseconds)"
            echo "performance_score: $PERFORMANCE_SCORE"
            echo "accessibility_score: $ACCESSIBILITY_SCORE"
            echo "best_practices_score: $BEST_PRACTICES_SCORE"
            echo "seo_score: $SEO_SCORE"
          } > performance-metrics.json

      - name: ğŸ“Š Web Vitals Analysis
        run: |
          echo "ğŸ“Š Analisando Web Vitals..."

          # Verificar se o arquivo existe e tem dados vÃ¡lidos
          if [[ ! -f lighthouse-report.json ]]; then
            echo "âš ï¸  lighthouse-report.json nÃ£o encontrado - pulando anÃ¡lise Web Vitals"
            exit 0
          fi

          # Verificar se hÃ¡ erro no report
          if jq -e '.error' lighthouse-report.json > /dev/null 2>&1; then
            echo "âš ï¸  Lighthouse report contÃ©m erro - pulando anÃ¡lise Web Vitals"
            exit 0
          fi

          # Extrair Web Vitals do relatÃ³rio do Lighthouse com fallback
          LCP=$(jq '.audits."largest-contentful-paint".numericValue // 0' lighthouse-report.json 2>/dev/null || echo "0")
          FID=$(jq '.audits."max-potential-fid".numericValue // 0' lighthouse-report.json 2>/dev/null || echo "0")
          CLS=$(jq '.audits."cumulative-layout-shift".numericValue // 0' lighthouse-report.json 2>/dev/null || echo "0")

          echo "ğŸ–¼ï¸  LCP (Largest Contentful Paint): ${LCP}ms"
          echo "ğŸ‘† FID (First Input Delay): ${FID}ms"
          echo "ğŸ“ CLS (Cumulative Layout Shift): $CLS"

          # Verificar thresholds apenas se temos valores vÃ¡lidos
          if (( $(echo "$LCP > 0 && $LCP > 2500" | bc -l 2>/dev/null || echo "0") )); then
            echo "âš ï¸  ALERTA: LCP muito alto (${LCP}ms)"
          fi

          if (( $(echo "$CLS > 0.1" | bc -l 2>/dev/null || echo "0") )); then
            echo "âš ï¸  ALERTA: CLS alto ($CLS)"
          fi

      - name: ğŸ“¤ Upload RelatÃ³rios de Performance
        if: always() # Upload artifacts even if previous steps failed
        uses: actions/upload-artifact@v4.4.3
        with:
          name: performance-reports
          path: |
            lighthouse-report.json
            performance-metrics.json

  # ==========================================
  # ğŸ”’ VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A
  # ==========================================

  security-check:
    name: "ğŸ”’ VerificaÃ§Ã£o de SeguranÃ§a"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'security'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar dependÃªncias
        run: npm ci

      - name: ğŸ” VerificaÃ§Ã£o de Vulnerabilidades
        id: audit
        run: |
          echo "ğŸ” Verificando vulnerabilidades..."

          # Run audit but don't let a non-zero exit stop the job; capture JSON
          npm audit --audit-level=moderate --json > audit-results.json || true

          # Guard against missing file
          if [[ ! -s audit-results.json ]]; then
            echo "{}" > audit-results.json
          fi

          CRITICAL_VULNS=$(jq '.metadata.vulnerabilities.critical // 0' audit-results.json)
          HIGH_VULNS=$(jq '.metadata.vulnerabilities.high // 0' audit-results.json)
          MODERATE_VULNS=$(jq '.metadata.vulnerabilities.moderate // 0' audit-results.json)

          echo "ğŸš¨ Vulnerabilidades crÃ­ticas: $CRITICAL_VULNS"
          echo "âš ï¸  Vulnerabilidades altas: $HIGH_VULNS"
          echo "ğŸŸ¡ Vulnerabilidades moderadas: $MODERATE_VULNS"

          # Expose as step outputs for conditional steps later
          echo "critical_vulns=$CRITICAL_VULNS" >> $GITHUB_OUTPUT
          echo "high_vulns=$HIGH_VULNS" >> $GITHUB_OUTPUT
          echo "moderate_vulns=$MODERATE_VULNS" >> $GITHUB_OUTPUT

          # Also set an env flag so other steps can read if needed
          if [[ "$CRITICAL_VULNS" -gt 0 ]]; then
            echo "CRITICAL_FOUND=true" >> $GITHUB_ENV
            echo "âŒ ALERTA: Vulnerabilidades crÃ­ticas encontradas!"
          else
            echo "CRITICAL_FOUND=false" >> $GITHUB_ENV
            echo "âœ… Nenhuma vulnerabilidade crÃ­tica encontrada"
          fi

      - name: ğŸš¨ Criar Issue para Vulnerabilidades CrÃ­ticas
        if: steps.audit.outputs.critical_vulns != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const auditData = JSON.parse(fs.readFileSync('audit-results.json', 'utf8'));
            const critical = parseInt('${{ steps.audit.outputs.critical_vulns }}');
            const high = parseInt('${{ steps.audit.outputs.high_vulns }}');
            const moderate = parseInt('${{ steps.audit.outputs.moderate_vulns }}');

            // Check if there's already an open issue about vulnerabilities
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'security,automated'
            });

            const hasOpenSecurityIssue = existingIssues.data.some(issue =>
              issue.title.includes('critical npm vulnerability')
            );

            if (hasOpenSecurityIssue) {
              console.log('âš ï¸  JÃ¡ existe uma issue aberta sobre vulnerabilidades de seguranÃ§a');
              return;
            }

            const body = [
              '## ğŸš¨ Vulnerabilidades de SeguranÃ§a Detectadas',
              '',
              'O monitoramento automÃ¡tico de seguranÃ§a detectou vulnerabilidades crÃ­ticas nas dependÃªncias do projeto.',
              '',
              '### ğŸ“Š Resumo',
              '',
              `- **CrÃ­ticas**: ${critical}`,
              `- **Altas**: ${high}`,
              `- **Moderadas**: ${moderate}`,
              '',
              '### ğŸ”§ AÃ§Ãµes Recomendadas',
              '',
              '1. **Executar localmente**:',
              '```bash',
              'npm audit --json > audit-results.json',
              "jq '.' audit-results.json",
              '```',
              '',
              '2. **Tentar correÃ§Ã£o automÃ¡tica**:',
              '```bash',
              'npm audit fix',
              '# Se necessÃ¡rio (cuidado com breaking changes):',
              'npm audit fix --force',
              '```',
              '',
              '3. **Revisar e atualizar manualmente**:',
              '   - Verificar package.json para dependÃªncias desatualizadas',
              '   - Atualizar versÃµes problemÃ¡ticas',
              '   - Considerar substituiÃ§Ã£o de bibliotecas abandonadas',
              '',
              '### ğŸ“„ RelatÃ³rio Completo',
              '',
              'O relatÃ³rio JSON completo do npm audit estÃ¡ disponÃ­vel nos artefatos do workflow.',
              '',
              `**Workflow Run**: \${{ github.server_url }}/\${{ github.repository }}/actions/runs/\${{ github.run_id }}`,
              '',
              '---',
              `*Issue criada automaticamente pelo workflow de monitoramento em ${new Date().toISOString()}*`
            ].join('\\n');

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ğŸš¨ Security: ${critical} critical npm vulnerability(ies) detected`,
              body: body,
              labels: ['security', 'automated', 'dependencies']
            });

            console.log('âœ… Issue de seguranÃ§a criada com sucesso');

      - name: ğŸ›¡ï¸  VerificaÃ§Ã£o de Headers de SeguranÃ§a
        run: |
          echo "ğŸ›¡ï¸  Verificando headers de seguranÃ§a..."

          # URL alvo
          TARGET_URL="https://assistente-juridico-github.vercel.app"

          # Verificar headers importantes
          HEADERS=$(curl -s -I $TARGET_URL)

          # Verificar Content Security Policy
          if echo "$HEADERS" | grep -q "Content-Security-Policy"; then
            echo "âœ… CSP presente"
          else
            echo "âš ï¸  CSP ausente"
          fi

          # Verificar HTTPS Strict Transport Security
          if echo "$HEADERS" | grep -q "Strict-Transport-Security"; then
            echo "âœ… HSTS presente"
          else
            echo "âš ï¸  HSTS ausente"
          fi

          # Verificar X-Frame-Options
          if echo "$HEADERS" | grep -q "X-Frame-Options"; then
            echo "âœ… X-Frame-Options presente"
          else
            echo "âš ï¸  X-Frame-Options ausente"
          fi

      - name: ğŸ” VerificaÃ§Ã£o de Certificado SSL
        run: |
          echo "ğŸ” Verificando certificado SSL..."

          # URL alvo
          TARGET_URL="https://assistente-juridico-github.vercel.app"
          DOMAIN=$(echo $TARGET_URL | sed 's|https://||')

          # Verificar validade do certificado
          CERT_INFO=$(openssl s_client -connect ${DOMAIN}:443 -servername ${DOMAIN} < /dev/null 2>/dev/null | openssl x509 -noout -dates)

          if [[ $? -eq 0 ]]; then
            echo "âœ… Certificado SSL vÃ¡lido"
            echo "$CERT_INFO"
          else
            echo "âš ï¸  NÃ£o foi possÃ­vel verificar certificado SSL (usando URL padrÃ£o)"
          fi

      - name: ğŸ“¤ Upload RelatÃ³rios de SeguranÃ§a
        if: always()  # Upload even if vulnerabilities were found
        uses: actions/upload-artifact@v4.4.3
        with:
          name: security-reports
          path: |
            audit-results.json

  # ==========================================
  # ğŸ“¦ VERIFICAÃ‡ÃƒO DE DEPENDÃŠNCIAS
  # ==========================================

  dependency-check:
    name: "ğŸ“¦ VerificaÃ§Ã£o de DependÃªncias"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'dependencies'

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: ğŸ“¦ Instalar DependÃªncias
        run: npm ci

      - name: ğŸ“¦ Verificar DependÃªncias Desatualizadas
        run: |
          echo "ğŸ“¦ Verificando dependÃªncias desatualizadas..."

          # Verificar pacotes desatualizados (|| true para nÃ£o falhar o workflow)
          npm outdated --json > outdated-packages.json || true

          # Contar pacotes desatualizados
          OUTDATED_COUNT=$(jq 'length' outdated-packages.json 2>/dev/null || echo "0")
          echo "ğŸ“Š Pacotes desatualizados: $OUTDATED_COUNT"

          if [[ "$OUTDATED_COUNT" -gt 10 ]]; then
            echo "âš ï¸  ALERTA: Muitos pacotes desatualizados ($OUTDATED_COUNT)"
          fi

      - name: ğŸ” Verificar LicenÃ§as
        run: |
          echo "ğŸ” Verificando licenÃ§as de dependÃªncias..."

          # Verificar licenÃ§as problemÃ¡ticas
          npx license-checker --json > license-report.json

          # Verificar se hÃ¡ licenÃ§as nÃ£o permitidas
          PROBLEMATIC_LICENSES=$(jq '[.[] | select(.licenses | test("GPL|LGPL|MS-PL"))] | length' license-report.json)

          if [[ "$PROBLEMATIC_LICENSES" -gt 0 ]]; then
            echo "âš ï¸  ALERTA: $PROBLEMATIC_LICENSES dependÃªncias com licenÃ§as potencialmente problemÃ¡ticas"
          fi

      - name: ğŸ“¤ Upload RelatÃ³rios de DependÃªncias
        uses: actions/upload-artifact@v4.4.3
        with:
          name: dependency-reports
          path: |
            outdated-packages.json
            license-report.json

  # ==========================================
  # ğŸ“Š DASHBOARD DE MONITORAMENTO
  # ==========================================

  monitoring-dashboard:
    name: "ğŸ“Š Dashboard de Monitoramento"
    runs-on: ubuntu-latest
    needs: [health-check, performance-monitoring, security-check, dependency-check]
    if: always()

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ“Š Gerar RelatÃ³rio Consolidado
        run: |
          echo "ğŸ“Š Gerando relatÃ³rio consolidado de monitoramento..."

          # Criar relatÃ³rio markdown
          {
            echo "# ğŸ“Š RelatÃ³rio de Monitoramento - $(date)"
            echo ""
            echo "## ğŸ¥ Status de SaÃºde"
            echo "- Health Check: ${{ needs.health-check.result }}"
            echo ""
            echo "## ğŸ“ˆ Performance"
            echo "- Performance Monitoring: ${{ needs.performance-monitoring.result }}"
            echo ""
            echo "## ğŸ”’ SeguranÃ§a"
            echo "- Security Check: ${{ needs.security-check.result }}"
            echo ""
            echo "## ğŸ“¦ DependÃªncias"
            echo "- Dependency Check: ${{ needs.dependency-check.result }}"
            echo ""
            echo "## ğŸ“‹ Resumo Executivo"
          } > monitoring-report.md

          # Determinar status geral
          if [[ "${{ needs.health-check.result }}" == "success" && \
                "${{ needs.performance-monitoring.result }}" == "success" && \
                "${{ needs.security-check.result }}" == "success" && \
                "${{ needs.dependency-check.result }}" == "success" ]]; then
            echo "âœ… **STATUS GERAL: TODOS OS CHECKS PASSARAM**" >> monitoring-report.md
            echo "STATUS=success" >> $GITHUB_ENV
          else
            echo "âŒ **STATUS GERAL: PROBLEMAS DETECTADOS**" >> monitoring-report.md
            echo "STATUS=failure" >> $GITHUB_ENV
          fi

          echo "" >> monitoring-report.md
          echo "*RelatÃ³rio gerado em: $(date -Iseconds)*" >> monitoring-report.md

      - name: ğŸ“¤ Upload RelatÃ³rio Consolidado
        uses: actions/upload-artifact@v4.4.3
        with:
          name: monitoring-dashboard
          path: monitoring-report.md

      - name: ğŸ“¢ Notificar Status de Monitoramento
        run: |
          echo "ğŸ“¢ Enviando notificaÃ§Ã£o de monitoramento..."

          # Verificar se houve falhas em algum job
          if [[ "${{ job.status }}" != "success" ]]; then
            echo "âŒ ALERTA: Problemas detectados no monitoramento!"
            echo "ğŸ“§ Enviando notificaÃ§Ã£o de alerta..."
            # Aqui vocÃª pode integrar com sistemas de notificaÃ§Ã£o
          else
            echo "âœ… Monitoramento concluÃ­do com sucesso"
          fi

      - name: ğŸ’¾ Arquivar RelatÃ³rios Anteriores
        run: |
          echo "ğŸ’¾ Arquivando relatÃ³rios para histÃ³rico..."

          # Criar diretÃ³rio de histÃ³rico se nÃ£o existir
          mkdir -p monitoring-history

          # Mover artefatos para histÃ³rico (se existirem)
          if [[ -f "health-metrics.json" ]]; then
            cp health-metrics.json monitoring-history/health-$(date +%Y%m%d-%H%M%S).json
          fi

          # Manter apenas Ãºltimos 30 dias de histÃ³rico
          find monitoring-history -name "*.json" -mtime +30 -delete

      - name: ğŸ“¤ Upload HistÃ³rico
        uses: actions/upload-artifact@v4.4.3
        with:
          name: monitoring-history
          path: monitoring-history/

  # ==========================================
  # ğŸš¨ ALERTAS E NOTIFICAÃ‡Ã•ES
  # ==========================================

  alerts-and-notifications:
    name: "ğŸš¨ Alertas e NotificaÃ§Ãµes"
    runs-on: ubuntu-latest
    needs: monitoring-dashboard
    if: failure()

    steps:
      - name: ğŸš¨ Preparar Alertas
        run: |
          echo "ğŸš¨ Preparando alertas de monitoramento..."

          # Identificar quais checks falharam
          # Verificar status dos jobs (simplificado)
          FAILED_CHECKS=""

          # Como os jobs podem nÃ£o existir ou ter nomes diferentes,
          # vamos usar uma verificaÃ§Ã£o mais simples baseada no status atual
          if [[ "${{ job.status }}" != "success" ]]; then
            FAILED_CHECKS="Monitoramento"
          fi

          echo "FAILED_CHECKS=$FAILED_CHECKS" >> $GITHUB_ENV

          # Criar mensagem de alerta
          {
            echo "## ğŸš¨ ALERTA DE MONITORAMENTO"
            echo ""
            echo "**Timestamp:** $(date -Iseconds)"
            echo "**Environment:** Production"
            echo "**Failed Checks:**$FAILED_CHECKS"
            echo ""
            echo "### ğŸ“‹ AÃ§Ãµes Recomendadas"
            echo "1. Verificar logs detalhados nos artefatos do workflow"
            echo "2. Investigar a causa raiz das falhas"
            echo "3. Executar correÃ§Ãµes necessÃ¡rias"
            echo "4. Re-executar monitoramento apÃ³s correÃ§Ãµes"
            echo ""
            echo "*Este Ã© um alerta automÃ¡tico do sistema de monitoramento*"
          } > alert-message.md

      - name: ğŸ“§ Enviar Alerta por Email
        run: |
          echo "ğŸ“§ Enviando alerta por email..."
          # Implementar envio de email usando serviÃ§o como SendGrid, etc.
          echo "Alerta enviado para equipe de desenvolvimento"

      - name: ğŸ’¬ Slack Alert
        run: |
          echo "ğŸ’¬ Enviando alerta para Slack..."
          # Implementar integraÃ§Ã£o com Slack webhook
          cat alert-message.md

      - name: ğŸ“± Teams Alert
        run: |
          echo "ğŸ“± Enviando alerta para Microsoft Teams..."
          # Implementar integraÃ§Ã£o com Teams webhook

      - name: ğŸ“ PagerDuty Alert (se crÃ­tico)
        run: |
          echo "ğŸ“ Verificando se alerta Ã© crÃ­tico..."
          # Implementar integraÃ§Ã£o com PagerDuty para alertas crÃ­ticos
          echo "Alerta crÃ­tico enviado para PagerDuty"

      - name: ğŸ“¤ Upload Mensagem de Alerta
        uses: actions/upload-artifact@v4.4.3
        with:
          name: monitoring-alerts
          path: alert-message.md
