name: Monitoramento Cont√≠nuo e Alertas

on:
  schedule:
    # Executar 2x ao dia (6h e 18h UTC) - suficiente para monitoramento
    - cron: "0 6,18 * * *"
  workflow_dispatch:
    inputs:
      check_type:
        description: "Tipo de verifica√ß√£o"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - health
          - performance
          - security
          - dependencies
      environment:
        description: "Ambiente para verificar"
        required: false
        default: "production"
        type: choice
        options:
          - production
          - staging
          - both

concurrency:
  group: monitoring-${{ github.ref }}
  # N√£o cancelar execu√ß√µes em andamento para workflows de monitoramento
  # Cada execu√ß√£o agendada deve completar para garantir alertas
  cancel-in-progress: false

# Timeout global para evitar execu√ß√µes longas
env:
  WORKFLOW_TIMEOUT: 10

jobs:
  # ==========================================
  # üè• VERIFICA√á√ÉO DE SA√öDE
  # ==========================================

  health-check:
    name: "üè• Verifica√ß√£o de Sa√∫de"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    # Simplified condition: run on schedule or when explicitly requested
    if: |
      github.event_name == 'schedule' ||
      github.event_name == 'workflow_dispatch' && (
        github.event.inputs.check_type == 'all' ||
        github.event.inputs.check_type == 'health'
      )

    strategy:
      matrix:
        # Simplified matrix strategy
        environment: >-
          ${{
            github.event_name != 'workflow_dispatch' && fromJSON('["production"]') ||
            github.event.inputs.environment == 'both' && fromJSON('["production", "staging"]') ||
            github.event.inputs.environment == 'staging' && fromJSON('["staging"]') ||
            fromJSON('["production"]')
          }}

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: üì¶ Instalar depend√™ncias
        run: npm ci

      - name: üè• Health Check B√°sico
        run: |
          echo "üè• Executando health check b√°sico..."

          # Prefer explicit environment overrides; fallback to default publicly-known URL
          if [[ -n "${{ secrets.PRODUCTION_URL }}" ]] && [[ "${{ matrix.environment }}" == "production" ]]; then
            APP_URL="${{ secrets.PRODUCTION_URL }}"
          elif [[ -n "${{ secrets.STAGING_URL }}" ]] && [[ "${{ matrix.environment }}" == "staging" ]]; then
            APP_URL="${{ secrets.STAGING_URL }}"
          else
            if [[ "${{ matrix.environment }}" == "production" ]]; then
              APP_URL="https://assistente-juridico-github.vercel.app"
            else
              APP_URL="https://assistente-juridico-github-staging.vercel.app"
            fi
          fi

          echo "üåê Verificando: $APP_URL"

          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$APP_URL" || echo "000")
          echo "HTTP_STATUS=$HTTP_STATUS"

          if [[ "$HTTP_STATUS" -ne 200 ]]; then
            echo "‚ö†Ô∏è  HTTP Status: $HTTP_STATUS for $APP_URL"
            # Do NOT mask errors. Export status so subsequent jobs can decide what to do.
          else
            echo "‚úÖ HTTP Status: $HTTP_STATUS"
          fi

          # Verificar tempo de resposta apenas se o site estiver acess√≠vel
          if [[ "$HTTP_STATUS" -eq 200 ]]; then
            RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$APP_URL" 2>/dev/null || echo "0.0")
            echo "‚è±Ô∏è  Tempo de resposta: ${RESPONSE_TIME}s"

            if (( $(echo "$RESPONSE_TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
              echo "‚ö†Ô∏è  Tempo de resposta alto: ${RESPONSE_TIME}s"
            fi
          else
            RESPONSE_TIME="0.0"
          fi

          # Exportar para pr√≥ximos steps
          echo "HTTP_STATUS=$HTTP_STATUS" >> $GITHUB_ENV
          echo "RESPONSE_TIME=$RESPONSE_TIME" >> $GITHUB_ENV
          echo "APP_URL=$APP_URL" >> $GITHUB_ENV

      - name: üîç Verifica√ß√£o de APIs Cr√≠ticas
        run: |
          echo "üîç Verificando APIs cr√≠ticas..."

          # URL base do app
          BASE_URL="https://assistente-juridico-github.vercel.app"

          # Lista de endpoints cr√≠ticos para verificar
          ENDPOINTS=(
            "/api/status"
            "/api/kv"
            "/api/agents"
            "/api/expedientes"
            "/api/legal-services"
          )

          for endpoint in "${ENDPOINTS[@]}"; do
            FULL_URL="$BASE_URL$endpoint"
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$FULL_URL" || echo "000")

            if [[ "$STATUS" -eq 200 ]] || [[ "$STATUS" -eq 401 ]] || [[ "$STATUS" -eq 405 ]]; then
              echo "‚úÖ $endpoint: OK (Status: $STATUS)"
            else
              echo "‚ö†Ô∏è  $endpoint: $STATUS (endpoint pode estar indispon√≠vel)"
            fi
          done

      - name: üíæ Verifica√ß√£o de Banco de Dados
        run: |
          echo "üíæ Verificando conectividade do banco..."

          # Aqui voc√™ pode adicionar verifica√ß√µes espec√≠ficas do seu banco
          # Por exemplo, verificar se Upstash Redis responde
          if [[ -n "${{ secrets.UPSTASH_REDIS_REST_URL }}" ]]; then
            REDIS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ secrets.UPSTASH_REDIS_REST_URL }}/ping")
            if [[ "$REDIS_STATUS" -eq 200 ]]; then
              echo "‚úÖ Redis: OK"
            else
              echo "‚ùå Redis: $REDIS_STATUS"
            fi
          fi

      - name: üìä Coletar M√©tricas de Sa√∫de
        run: |
          echo "üìä Coletando m√©tricas de sa√∫de..."

          # Salvar m√©tricas em arquivo para upload
          {
            echo "timestamp: $(date -Iseconds)"
            echo "environment: ${{ matrix.environment }}"
            echo "http_status: $HTTP_STATUS"
            echo "response_time: $RESPONSE_TIME"
            echo "uptime_check: true"
          } > health-metrics.json

      - name: üì§ Upload M√©tricas de Sa√∫de
        uses: actions/upload-artifact@v4.4.3
        with:
          name: health-metrics-${{ matrix.environment }}
          path: health-metrics.json

  # ==========================================
  # üìà MONITORAMENTO DE PERFORMANCE
  # ==========================================

  performance-monitoring:
    name: "üìà Monitoramento de Performance"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'performance' || github.event_name == 'schedule'
    needs: health-check

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: üì¶ Instalar depend√™ncias
        run: npm ci

      - name: üèÉ Lighthouse Performance Audit
        run: |
          echo "üèÉ Executando Lighthouse performance audit..."

          # Ensure TARGET_URL can be overridden
          TARGET_URL="${{ secrets.PRODUCTION_URL }}"
          if [[ -z "$TARGET_URL" ]]; then
            TARGET_URL="https://assistente-juridico-github.vercel.app"
          fi

          echo "üéØ Target URL: $TARGET_URL"

          # Check status before running Lighthouse
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 20 "$TARGET_URL" || echo "000")
          echo "Checking TARGET_URL: $TARGET_URL -> HTTP $HTTP_STATUS"

          if [[ "$HTTP_STATUS" -ne 200 ]]; then
            echo "‚ùå Skipping Lighthouse because target is not reachable (HTTP $HTTP_STATUS)"
            # Create a minimal report so the step has artifacts to inspect
            jq -n --arg url "$TARGET_URL" --arg status "$HTTP_STATUS" '{error: "target_not_reachable", target: $url, http_status: $status}' > lighthouse-report.json || echo '{"error":"target_not_reachable"}' > lighthouse-report.json
            echo "performance_score: 0" > performance-metrics.json
            echo "accessibility_score: 0" >> performance-metrics.json
            echo "best_practices_score: 0" >> performance-metrics.json
            echo "seo_score: 0" >> performance-metrics.json
            echo "timestamp: $(date -Iseconds)" >> performance-metrics.json
            echo "‚ö†Ô∏è  Lighthouse skipped - site not reachable"
            exit 0
          fi

          # Try up to 3 times in case of intermittent failures
          TRIES=0
          MAX_TRIES=3
          while [[ $TRIES -lt $MAX_TRIES ]]; do
            TRIES=$((TRIES + 1))
            echo "Running Lighthouse attempt $TRIES/$MAX_TRIES..."
            npx lighthouse "$TARGET_URL" \
              --output=json \
              --output-path=./lighthouse-report.json \
              --only-categories=performance,accessibility,best-practices,seo \
              --chrome-flags="--headless --disable-gpu --no-sandbox --disable-dev-shm-usage --single-process" && break || {
                echo "Lighthouse attempt $TRIES failed."
                sleep 3
              }
          done

          if [[ ! -f lighthouse-report.json ]]; then
            echo "‚ùå Lighthouse did not produce a report after $MAX_TRIES attempts."
            jq -n '{error: "lighthouse_failed"}' > lighthouse-report.json || echo '{"error":"lighthouse_failed"}' > lighthouse-report.json
            echo "performance_score: 0" > performance-metrics.json
            echo "accessibility_score: 0" >> performance-metrics.json
            echo "best_practices_score: 0" >> performance-metrics.json
            echo "seo_score: 0" >> performance-metrics.json
            echo "timestamp: $(date -Iseconds)" >> performance-metrics.json
            # allow workflow to continue so monitoring-dashboard aggregates results
            exit 0
          fi

          # Extract metrics (existing logic)
          PERFORMANCE_SCORE=$(jq '.categories.performance.score * 100' lighthouse-report.json 2>/dev/null || echo "0")
          ACCESSIBILITY_SCORE=$(jq '.categories.accessibility.score * 100' lighthouse-report.json 2>/dev/null || echo "0")
          BEST_PRACTICES_SCORE=$(jq '.categories."best-practices".score * 100' lighthouse-report.json 2>/dev/null || echo "0")
          SEO_SCORE=$(jq '.categories.seo.score * 100' lighthouse-report.json 2>/dev/null || echo "0")

          echo "üìä Performance Score: $PERFORMANCE_SCORE"
          echo "‚ôø Accessibility Score: $ACCESSIBILITY_SCORE"
          echo "‚ú® Best Practices Score: $BEST_PRACTICES_SCORE"
          echo "üîç SEO Score: $SEO_SCORE"

          # Alertar se performance estiver baixa
          if (( $(echo "$PERFORMANCE_SCORE < 80" | bc -l 2>/dev/null || echo "0") )); then
            echo "‚ö†Ô∏è  ALERTA: Performance score baixo ($PERFORMANCE_SCORE)"
          fi

          # Salvar m√©tricas
          {
            echo "timestamp: $(date -Iseconds)"
            echo "performance_score: $PERFORMANCE_SCORE"
            echo "accessibility_score: $ACCESSIBILITY_SCORE"
            echo "best_practices_score: $BEST_PRACTICES_SCORE"
            echo "seo_score: $SEO_SCORE"
          } > performance-metrics.json

      - name: üìä Web Vitals Analysis
        run: |
          echo "üìä Analisando Web Vitals..."

          # Verificar se o arquivo existe e tem dados v√°lidos
          if [[ ! -f lighthouse-report.json ]]; then
            echo "‚ö†Ô∏è  lighthouse-report.json n√£o encontrado - pulando an√°lise Web Vitals"
            exit 0
          fi

          # Verificar se h√° erro no report
          if jq -e '.error' lighthouse-report.json > /dev/null 2>&1; then
            echo "‚ö†Ô∏è  Lighthouse report cont√©m erro - pulando an√°lise Web Vitals"
            exit 0
          fi

          # Extrair Web Vitals do relat√≥rio do Lighthouse com fallback
          LCP=$(jq '.audits."largest-contentful-paint".numericValue // 0' lighthouse-report.json 2>/dev/null || echo "0")
          FID=$(jq '.audits."max-potential-fid".numericValue // 0' lighthouse-report.json 2>/dev/null || echo "0")
          CLS=$(jq '.audits."cumulative-layout-shift".numericValue // 0' lighthouse-report.json 2>/dev/null || echo "0")

          echo "üñºÔ∏è  LCP (Largest Contentful Paint): ${LCP}ms"
          echo "üëÜ FID (First Input Delay): ${FID}ms"
          echo "üìê CLS (Cumulative Layout Shift): $CLS"

          # Verificar thresholds apenas se temos valores v√°lidos
          if (( $(echo "$LCP > 0 && $LCP > 2500" | bc -l 2>/dev/null || echo "0") )); then
            echo "‚ö†Ô∏è  ALERTA: LCP muito alto (${LCP}ms)"
          fi

          if (( $(echo "$CLS > 0.1" | bc -l 2>/dev/null || echo "0") )); then
            echo "‚ö†Ô∏è  ALERTA: CLS alto ($CLS)"
          fi

      - name: üì§ Upload Relat√≥rios de Performance
        if: always() # Upload artifacts even if previous steps failed
        uses: actions/upload-artifact@v4.4.3
        with:
          name: performance-reports
          path: |
            lighthouse-report.json
            performance-metrics.json

  # ==========================================
  # üîí VERIFICA√á√ÉO DE SEGURAN√áA
  # ==========================================

  security-check:
    name: "üîí Verifica√ß√£o de Seguran√ßa"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'security'

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: üì¶ Instalar depend√™ncias
        run: npm ci

      - name: üîç Verifica√ß√£o de Vulnerabilidades
        id: audit
        run: |
          echo "üîç Verificando vulnerabilidades..."

          # Run audit but don't let a non-zero exit stop the job; capture JSON
          npm audit --audit-level=moderate --json > audit-results.json || true

          # Guard against missing file
          if [[ ! -s audit-results.json ]]; then
            echo "{}" > audit-results.json
          fi

          CRITICAL_VULNS=$(jq '.metadata.vulnerabilities.critical // 0' audit-results.json)
          HIGH_VULNS=$(jq '.metadata.vulnerabilities.high // 0' audit-results.json)
          MODERATE_VULNS=$(jq '.metadata.vulnerabilities.moderate // 0' audit-results.json)

          echo "üö® Vulnerabilidades cr√≠ticas: $CRITICAL_VULNS"
          echo "‚ö†Ô∏è  Vulnerabilidades altas: $HIGH_VULNS"
          echo "üü° Vulnerabilidades moderadas: $MODERATE_VULNS"

          # Expose as step outputs for conditional steps later
          echo "critical_vulns=$CRITICAL_VULNS" >> $GITHUB_OUTPUT
          echo "high_vulns=$HIGH_VULNS" >> $GITHUB_OUTPUT
          echo "moderate_vulns=$MODERATE_VULNS" >> $GITHUB_OUTPUT

          # Also set an env flag so other steps can read if needed
          if [[ "$CRITICAL_VULNS" -gt 0 ]]; then
            echo "CRITICAL_FOUND=true" >> $GITHUB_ENV
            echo "‚ùå ALERTA: Vulnerabilidades cr√≠ticas encontradas!"
            # Fail workflow for critical vulnerabilities in strict security mode
            echo "::error::Vulnerabilidades cr√≠ticas detectadas. O workflow deve falhar."
            exit 1
          else
            echo "CRITICAL_FOUND=false" >> $GITHUB_ENV
            echo "‚úÖ Nenhuma vulnerabilidade cr√≠tica encontrada"
          fi

      - name: üö® Criar Issue para Vulnerabilidades Cr√≠ticas
        if: steps.audit.outputs.critical_vulns != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const auditData = JSON.parse(fs.readFileSync('audit-results.json', 'utf8'));
            const critical = parseInt('${{ steps.audit.outputs.critical_vulns }}');
            const high = parseInt('${{ steps.audit.outputs.high_vulns }}');
            const moderate = parseInt('${{ steps.audit.outputs.moderate_vulns }}');

            // Check if there's already an open issue about vulnerabilities
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'security,automated'
            });

            const hasOpenSecurityIssue = existingIssues.data.some(issue =>
              issue.title.includes('critical npm vulnerability')
            );

            if (hasOpenSecurityIssue) {
              console.log('‚ö†Ô∏è  J√° existe uma issue aberta sobre vulnerabilidades de seguran√ßa');
              return;
            }

            const body = [
              '## üö® Vulnerabilidades de Seguran√ßa Detectadas',
              '',
              'O monitoramento autom√°tico de seguran√ßa detectou vulnerabilidades cr√≠ticas nas depend√™ncias do projeto.',
              '',
              '### üìä Resumo',
              '',
              `- **Cr√≠ticas**: ${critical}`,
              `- **Altas**: ${high}`,
              `- **Moderadas**: ${moderate}`,
              '',
              '### üîß A√ß√µes Recomendadas',
              '',
              '1. **Executar localmente**:',
              '```bash',
              'npm audit --json > audit-results.json',
              "jq '.' audit-results.json",
              '```',
              '',
              '2. **Tentar corre√ß√£o autom√°tica**:',
              '```bash',
              'npm audit fix',
              '# Se necess√°rio (cuidado com breaking changes):',
              'npm audit fix --force',
              '```',
              '',
              '3. **Revisar e atualizar manualmente**:',
              '   - Verificar package.json para depend√™ncias desatualizadas',
              '   - Atualizar vers√µes problem√°ticas',
              '   - Considerar substitui√ß√£o de bibliotecas abandonadas',
              '',
              '### üìÑ Relat√≥rio Completo',
              '',
              'O relat√≥rio JSON completo do npm audit est√° dispon√≠vel nos artefatos do workflow.',
              '',
              `**Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`,
              '',
              '---',
              `*Issue criada automaticamente pelo workflow de monitoramento em ${new Date().toISOString()}*`
            ].join('\\n');

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Security: ${critical} critical npm vulnerability(ies) detected`,
              body: body,
              labels: ['security', 'automated', 'dependencies']
            });

            console.log('‚úÖ Issue de seguran√ßa criada com sucesso');

      - name: üõ°Ô∏è  Verifica√ß√£o de Headers de Seguran√ßa
        run: |
          echo "üõ°Ô∏è  Verificando headers de seguran√ßa..."

          # URL alvo
          TARGET_URL="https://assistente-juridico-github.vercel.app"

          # Verificar headers importantes
          HEADERS=$(curl -s -I $TARGET_URL)

          # Verificar Content Security Policy
          if echo "$HEADERS" | grep -q "Content-Security-Policy"; then
            echo "‚úÖ CSP presente"
          else
            echo "‚ö†Ô∏è  CSP ausente"
          fi

          # Verificar HTTPS Strict Transport Security
          if echo "$HEADERS" | grep -q "Strict-Transport-Security"; then
            echo "‚úÖ HSTS presente"
          else
            echo "‚ö†Ô∏è  HSTS ausente"
          fi

          # Verificar X-Frame-Options
          if echo "$HEADERS" | grep -q "X-Frame-Options"; then
            echo "‚úÖ X-Frame-Options presente"
          else
            echo "‚ö†Ô∏è  X-Frame-Options ausente"
          fi

      - name: üîê Verifica√ß√£o de Certificado SSL
        run: |
          echo "üîê Verificando certificado SSL..."

          # URL alvo
          TARGET_URL="https://assistente-juridico-github.vercel.app"
          # Use parameter expansion for more robust domain extraction
          DOMAIN="${TARGET_URL#https://}"
          DOMAIN="${DOMAIN#http://}"
          # Extract only the hostname (remove path and trailing slash)
          DOMAIN="${DOMAIN%%/*}"

          # Verificar validade do certificado
          CERT_INFO=$(openssl s_client -connect ${DOMAIN}:443 -servername ${DOMAIN} < /dev/null 2>/dev/null | openssl x509 -noout -dates)

          if [[ $? -eq 0 ]]; then
            echo "‚úÖ Certificado SSL v√°lido"
            echo "$CERT_INFO"
          else
            echo "‚ö†Ô∏è  N√£o foi poss√≠vel verificar certificado SSL (usando URL padr√£o)"
          fi

      - name: üì§ Upload Relat√≥rios de Seguran√ßa
        if: always() # Upload even if vulnerabilities were found
        uses: actions/upload-artifact@v4.4.3
        with:
          name: security-reports
          path: |
            audit-results.json

  # ==========================================
  # üì¶ VERIFICA√á√ÉO DE DEPEND√äNCIAS
  # ==========================================

  dependency-check:
    name: "üì¶ Verifica√ß√£o de Depend√™ncias"
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'dependencies'

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22.x"
          cache: "npm"

      - name: üì¶ Instalar Depend√™ncias
        run: npm ci

      - name: üì¶ Verificar Depend√™ncias Desatualizadas
        run: |
          echo "üì¶ Verificando depend√™ncias desatualizadas..."

          # Verificar pacotes desatualizados (|| true para n√£o falhar o workflow)
          npm outdated --json > outdated-packages.json || true

          # Contar pacotes desatualizados
          OUTDATED_COUNT=$(jq 'length' outdated-packages.json 2>/dev/null || echo "0")
          echo "üìä Pacotes desatualizados: $OUTDATED_COUNT"

          if [[ "$OUTDATED_COUNT" -gt 10 ]]; then
            echo "‚ö†Ô∏è  ALERTA: Muitos pacotes desatualizados ($OUTDATED_COUNT)"
          fi

      - name: üîç Verificar Licen√ßas
        run: |
          echo "üîç Verificando licen√ßas de depend√™ncias..."

          # Install license-checker explicitly for better CI/CD reliability
          npm install --no-save license-checker

          # Verificar licen√ßas problem√°ticas
          npx license-checker --json > license-report.json

          # Verificar se h√° licen√ßas n√£o permitidas
          PROBLEMATIC_LICENSES=$(jq '[.[] | select(.licenses | test("GPL|LGPL|MS-PL"))] | length' license-report.json)

          if [[ "$PROBLEMATIC_LICENSES" -gt 0 ]]; then
            echo "‚ö†Ô∏è  ALERTA: $PROBLEMATIC_LICENSES depend√™ncias com licen√ßas potencialmente problem√°ticas"
          fi

      - name: üì§ Upload Relat√≥rios de Depend√™ncias
        uses: actions/upload-artifact@v4.4.3
        with:
          name: dependency-reports
          path: |
            outdated-packages.json
            license-report.json

  # ==========================================
  # üìä DASHBOARD DE MONITORAMENTO
  # ==========================================

  monitoring-dashboard:
    name: "üìä Dashboard de Monitoramento"
    runs-on: ubuntu-latest
    needs: [health-check, performance-monitoring, security-check, dependency-check]
    if: always()

    steps:
      - name: üì• Checkout c√≥digo
        uses: actions/checkout@v4

      - name: üìä Gerar Relat√≥rio Consolidado
        run: |
          echo "üìä Gerando relat√≥rio consolidado de monitoramento..."

          # Criar relat√≥rio markdown
          {
            echo "# üìä Relat√≥rio de Monitoramento - $(date)"
            echo ""
            echo "## üè• Status de Sa√∫de"
            echo "- Health Check: ${{ needs.health-check.result }}"
            echo ""
            echo "## üìà Performance"
            echo "- Performance Monitoring: ${{ needs.performance-monitoring.result }}"
            echo ""
            echo "## üîí Seguran√ßa"
            echo "- Security Check: ${{ needs.security-check.result }}"
            echo ""
            echo "## üì¶ Depend√™ncias"
            echo "- Dependency Check: ${{ needs.dependency-check.result }}"
            echo ""
            echo "## üìã Resumo Executivo"
          } > monitoring-report.md

          # Determinar status geral
          if [[ "${{ needs.health-check.result }}" == "success" && \
                "${{ needs.performance-monitoring.result }}" == "success" && \
                "${{ needs.security-check.result }}" == "success" && \
                "${{ needs.dependency-check.result }}" == "success" ]]; then
            echo "‚úÖ **STATUS GERAL: TODOS OS CHECKS PASSARAM**" >> monitoring-report.md
            echo "STATUS=success" >> $GITHUB_ENV
          else
            echo "‚ùå **STATUS GERAL: PROBLEMAS DETECTADOS**" >> monitoring-report.md
            echo "STATUS=failure" >> $GITHUB_ENV
          fi

          echo "" >> monitoring-report.md
          echo "*Relat√≥rio gerado em: $(date -Iseconds)*" >> monitoring-report.md

      - name: üì§ Upload Relat√≥rio Consolidado
        uses: actions/upload-artifact@v4.4.3
        with:
          name: monitoring-dashboard
          path: monitoring-report.md

      - name: üì¢ Notificar Status de Monitoramento
        run: |
          echo "üì¢ Enviando notifica√ß√£o de monitoramento..."

          # Verificar se houve falhas em algum job
          if [[ "${{ job.status }}" != "success" ]]; then
            echo "‚ùå ALERTA: Problemas detectados no monitoramento!"
            echo "üìß Enviando notifica√ß√£o de alerta..."
            # Aqui voc√™ pode integrar com sistemas de notifica√ß√£o
          else
            echo "‚úÖ Monitoramento conclu√≠do com sucesso"
          fi

      - name: üíæ Arquivar Relat√≥rios Anteriores
        run: |
          echo "üíæ Arquivando relat√≥rios para hist√≥rico..."

          # Criar diret√≥rio de hist√≥rico se n√£o existir
          mkdir -p monitoring-history

          # Mover artefatos para hist√≥rico (se existirem)
          if [[ -f "health-metrics.json" ]]; then
            cp health-metrics.json monitoring-history/health-$(date +%Y%m%d-%H%M%S).json
          fi

          # Manter apenas √∫ltimos 30 dias de hist√≥rico
          find monitoring-history -name "*.json" -mtime +30 -delete

      - name: üì§ Upload Hist√≥rico
        uses: actions/upload-artifact@v4.4.3
        with:
          name: monitoring-history
          path: monitoring-history/

  # ==========================================
  # üö® ALERTAS E NOTIFICA√á√ïES
  # ==========================================

  alerts-and-notifications:
    name: "üö® Alertas e Notifica√ß√µes"
    runs-on: ubuntu-latest
    needs: monitoring-dashboard
    if: failure()

    steps:
      - name: üö® Preparar Alertas
        run: |
          echo "üö® Preparando alertas de monitoramento..."

          # Identificar quais checks falharam
          # Verificar status dos jobs (simplificado)
          FAILED_CHECKS=""

          # Como os jobs podem n√£o existir ou ter nomes diferentes,
          # vamos usar uma verifica√ß√£o mais simples baseada no status atual
          if [[ "${{ job.status }}" != "success" ]]; then
            FAILED_CHECKS="Monitoramento"
          fi

          echo "FAILED_CHECKS=$FAILED_CHECKS" >> $GITHUB_ENV

          # Criar mensagem de alerta
          {
            echo "## üö® ALERTA DE MONITORAMENTO"
            echo ""
            echo "**Timestamp:** $(date -Iseconds)"
            echo "**Environment:** Production"
            echo "**Failed Checks:**$FAILED_CHECKS"
            echo ""
            echo "### üìã A√ß√µes Recomendadas"
            echo "1. Verificar logs detalhados nos artefatos do workflow"
            echo "2. Investigar a causa raiz das falhas"
            echo "3. Executar corre√ß√µes necess√°rias"
            echo "4. Re-executar monitoramento ap√≥s corre√ß√µes"
            echo ""
            echo "*Este √© um alerta autom√°tico do sistema de monitoramento*"
          } > alert-message.md

      - name: üìß Enviar Alerta por Email
        run: |
          echo "üìß Enviando alerta por email..."
          # Implementar envio de email usando servi√ßo como SendGrid, etc.
          echo "Alerta enviado para equipe de desenvolvimento"

      - name: üí¨ Slack Alert
        run: |
          echo "üí¨ Enviando alerta para Slack..."
          # Implementar integra√ß√£o com Slack webhook
          cat alert-message.md

      - name: üì± Teams Alert
        run: |
          echo "üì± Enviando alerta para Microsoft Teams..."
          # Implementar integra√ß√£o com Teams webhook

      - name: üìû PagerDuty Alert (se cr√≠tico)
        run: |
          echo "üìû Verificando se alerta √© cr√≠tico..."
          # Implementar integra√ß√£o com PagerDuty para alertas cr√≠ticos
          echo "Alerta cr√≠tico enviado para PagerDuty"

      - name: üì§ Upload Mensagem de Alerta
        uses: actions/upload-artifact@v4.4.3
        with:
          name: monitoring-alerts
          path: alert-message.md
