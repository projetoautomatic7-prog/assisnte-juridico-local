spec:
  inputs:
    stage:
      default: deploy
      description: "Stage onde o deploy serÃ¡ executado"
    environment:
      default: "staging"
      description: "Ambiente de deploy: staging, production, development"
      options: ["staging", "production", "development"]
    docker_image:
      description: "Nome da imagem Docker a ser construÃ­da"
    docker_tag:
      default: "$CI_COMMIT_SHORT_SHA"
      description: "Tag da imagem Docker"
    registry_url:
      description: "URL do registry Docker"
    registry_user:
      description: "UsuÃ¡rio do registry Docker"
    registry_password:
      description: "Senha do registry Docker"
    kubernetes_namespace:
      description: "Namespace Kubernetes para deploy"
    kubernetes_config:
      description: "ConfiguraÃ§Ã£o Kubernetes (base64 encoded)"
    helm_chart:
      description: "Caminho para o chart Helm"
    helm_values:
      description: "Arquivo de values do Helm"
    health_check_url:
      description: "URL para verificaÃ§Ã£o de saÃºde da aplicaÃ§Ã£o"
    health_check_timeout:
      default: "300"
      description: "Timeout em segundos para health check"
    rollback_on_failure:
      default: true
      description: "Executar rollback automÃ¡tico em caso de falha"
    blue_green_deployment:
      default: false
      description: "Usar estratÃ©gia blue-green para deploy"
    canary_deployment:
      default: false
      description: "Usar estratÃ©gia canary para deploy"
    canary_percentage:
      default: "10"
      description: "Percentual de trÃ¡fego para canary deployment"

# Componente de Deploy em Container para AplicaÃ§Ãµes JurÃ­dicas
# Suporte a Docker, Kubernetes e estratÃ©gias avanÃ§adas de deploy

docker-build:
  stage: $[[ inputs.stage ]]
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - docker info
  script:
    - echo "ğŸ—ï¸  Construindo imagem Docker..."
    - |
      # Configurar registry
      if [ -n "$[[ inputs.registry_url ]]" ]; then
        echo "ğŸ” Fazendo login no registry..."
        echo "$[[ inputs.registry_password ]]" | docker login "$[[ inputs.registry_url ]]" -u "$[[ inputs.registry_user ]]" --password-stdin
      fi

      # Construir imagem
      IMAGE_NAME="$[[ inputs.docker_image ]]:$[[ inputs.docker_tag ]]"

      echo "ğŸ“¦ Construindo imagem: $IMAGE_NAME"
      docker build -t "$IMAGE_NAME" .

      # Tag adicional para latest se for main branch
      if [ "$CI_COMMIT_BRANCH" = "main" ] || [ "$CI_COMMIT_BRANCH" = "master" ]; then
        docker tag "$IMAGE_NAME" "$[[ inputs.docker_image ]]:latest"
      fi

      # Push da imagem
      echo "ğŸ“¤ Enviando imagem para registry..."
      docker push "$IMAGE_NAME"

      if [ "$CI_COMMIT_BRANCH" = "main" ] || [ "$CI_COMMIT_BRANCH" = "master" ]; then
        docker push "$[[ inputs.docker_image ]]:latest"
      fi

      echo "âœ… Imagem Docker construÃ­da e enviada: $IMAGE_NAME"
  artifacts:
    reports:
      dotenv: docker.env
    expire_in: 1 hour
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH
    - when: always

kubernetes-deploy:
  stage: $[[ inputs.stage ]]
  image: alpine:latest
  before_script:
    - apk add --no-cache curl kubectl helm
    - |
      # Configurar Kubernetes
      if [ -n "$[[ inputs.kubernetes_config ]]" ]; then
        echo "$[[ inputs.kubernetes_config ]]" | base64 -d > /tmp/kubeconfig
        export KUBECONFIG=/tmp/kubeconfig
      fi
  script:
    - echo "â˜¸ï¸  Executando deploy no Kubernetes..."
    - |
      # Configurar namespace
      NAMESPACE="$[[ inputs.kubernetes_namespace ]]"

      if [ -z "$NAMESPACE" ]; then
        case "$[[ inputs.environment ]]" in
          production)
            NAMESPACE="prod"
            ;;
          staging)
            NAMESPACE="staging"
            ;;
          development)
            NAMESPACE="dev"
            ;;
          *)
            NAMESPACE="default"
            ;;
        esac
      fi

      # Verificar se namespace existe
      kubectl get namespace "$NAMESPACE" >/dev/null 2>&1 || kubectl create namespace "$NAMESPACE"

      # EstratÃ©gia de deploy
      if [ "$[[ inputs.blue_green_deployment ]]" = "true" ]; then
        echo "ğŸ”„ Executando deploy Blue-Green..."

        # Determinar cores
        BLUE_EXISTS=$(kubectl get deployment blue -n "$NAMESPACE" --ignore-not-found=true)
        GREEN_EXISTS=$(kubectl get deployment green -n "$NAMESPACE" --ignore-not-found=true)

        if [ -n "$BLUE_EXISTS" ]; then
          ACTIVE_COLOR="blue"
          NEW_COLOR="green"
        else
          ACTIVE_COLOR="green"
          NEW_COLOR="blue"
        fi

        echo "ğŸ¨ Deploying to $NEW_COLOR environment..."

        # Deploy na nova cor
        if [ -n "$[[ inputs.helm_chart ]]" ]; then
          helm upgrade --install "$NEW_COLOR-app" "$[[ inputs.helm_chart ]]" \
            --namespace "$NAMESPACE" \
            --set image.tag="$[[ inputs.docker_tag ]]" \
            --set environment="$[[ inputs.environment ]]" \
            --values "$[[ inputs.helm_values ]]" \
            --wait
        else
          # Deploy direto com kubectl
          cat > deployment.yml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: $NEW_COLOR-app
            namespace: $NAMESPACE
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: assistente-juridico
                color: $NEW_COLOR
            template:
              metadata:
                labels:
                  app: assistente-juridico
                  color: $NEW_COLOR
              spec:
                containers:
                - name: app
                  image: $[[ inputs.docker_image ]]:$[[ inputs.docker_tag ]]
                  ports:
                  - containerPort: 80
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: $NEW_COLOR-service
            namespace: $NAMESPACE
          spec:
            selector:
              app: assistente-juridico
              color: $NEW_COLOR
            ports:
            - port: 80
              targetPort: 80
          EOF

          kubectl apply -f deployment.yml
        fi

        # Aguardar deploy ficar ready
        kubectl wait --for=condition=available --timeout=300s deployment/"$NEW_COLOR-app" -n "$NAMESPACE"

        # Health check
        if [ -n "$[[ inputs.health_check_url ]]" ]; then
          echo "ğŸ¥ Executando health check..."
          HEALTH_URL="$[[ inputs.health_check_url ]]"
          TIMEOUT="$[[ inputs.health_check_timeout ]]"

          # Substituir placeholder se necessÃ¡rio
          HEALTH_URL=$(echo "$HEALTH_URL" | sed "s/{{color}}/$NEW_COLOR/g")

          # Aguardar health check
          for i in $(seq 1 $TIMEOUT); do
            if curl -f -s "$HEALTH_URL" >/dev/null 2>&1; then
              echo "âœ… Health check passou!"
              break
            fi
            if [ $i -eq $TIMEOUT ]; then
              echo "âŒ Health check falhou apÃ³s $TIMEOUT segundos"
              if [ "$[[ inputs.rollback_on_failure ]]" = "true" ]; then
                echo "ğŸ”„ Executando rollback..."
                kubectl delete deployment "$NEW_COLOR-app" -n "$NAMESPACE"
              fi
              exit 1
            fi
            echo "â³ Aguardando health check... ($i/$TIMEOUT)"
            sleep 1
          done
        fi

        # Switch de trÃ¡fego (simulado - em produÃ§Ã£o usaria ingress/service mesh)
        echo "ğŸ”„ Switching traffic to $NEW_COLOR..."

        # Aqui seria implementado o switch real de trÃ¡fego
        # Por exemplo: atualizar ingress, service mesh, etc.

        echo "âœ… Deploy Blue-Green concluÃ­do!"

      elif [ "$[[ inputs.canary_deployment ]]" = "true" ]; then
        echo "ğŸ¦ Executando deploy Canary..."

        CANARY_PERCENTAGE="$[[ inputs.canary_percentage ]]"

        # Deploy canary
        if [ -n "$[[ inputs.helm_chart ]]" ]; then
          helm upgrade --install canary-app "$[[ inputs.helm_chart ]]" \
            --namespace "$NAMESPACE" \
            --set image.tag="$[[ inputs.docker_tag ]]" \
            --set environment="$[[ inputs.environment ]]" \
            --set replicas=1 \
            --values "$[[ inputs.helm_values ]]" \
            --wait
        fi

        # Aguardar canary ficar ready
        kubectl wait --for=condition=available --timeout=300s deployment/canary-app -n "$NAMESPACE"

        # Health check do canary
        if [ -n "$[[ inputs.health_check_url ]]" ]; then
          echo "ğŸ¥ Executando health check do canary..."
          for i in $(seq 1 30); do
            if curl -f -s "$[[ inputs.health_check_url ]]" >/dev/null 2>&1; then
              echo "âœ… Canary health check passou!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Canary health check falhou"
              kubectl delete deployment canary-app -n "$NAMESPACE"
              exit 1
            fi
            sleep 1
          done
        fi

        # Gradual rollout (simulado)
        echo "ğŸ“ˆ Executando rollout gradual para ${CANARY_PERCENTAGE}% do trÃ¡fego..."

        # Aqui seria implementado o rollout gradual
        # Usando service mesh, ingress controllers, etc.

        echo "âœ… Deploy Canary concluÃ­do!"

      else
        echo "ğŸ“¦ Executando deploy padrÃ£o..."

        # Deploy padrÃ£o
        if [ -n "$[[ inputs.helm_chart ]]" ]; then
          helm upgrade --install assistente-juridico "$[[ inputs.helm_chart ]]" \
            --namespace "$NAMESPACE" \
            --set image.tag="$[[ inputs.docker_tag ]]" \
            --set environment="$[[ inputs.environment ]]" \
            --values "$[[ inputs.helm_values ]]" \
            --wait
        else
          # Deploy direto
          cat > deployment.yml << EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: assistente-juridico
            namespace: $NAMESPACE
          spec:
            replicas: 3
            selector:
              matchLabels:
                app: assistente-juridico
            template:
              metadata:
                labels:
                  app: assistente-juridico
              spec:
                containers:
                - name: app
                  image: $[[ inputs.docker_image ]]:$[[ inputs.docker_tag ]]
                  ports:
                  - containerPort: 80
                  env:
                  - name: ENVIRONMENT
                    value: "$[[ inputs.environment ]]"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: assistente-juridico-service
            namespace: $NAMESPACE
          spec:
            selector:
              app: assistente-juridico
            ports:
            - port: 80
              targetPort: 80
            type: ClusterIP
          EOF

          kubectl apply -f deployment.yml
        fi

        # Aguardar deploy
        kubectl wait --for=condition=available --timeout=300s deployment/assistente-juridico -n "$NAMESPACE"

        echo "âœ… Deploy padrÃ£o concluÃ­do!"
      fi

      # Limpar kubeconfig
      rm -f /tmp/kubeconfig
  dependencies:
    - docker-build
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH && $[[ inputs.environment ]] != "development"
    - when: manual

health-check:
  stage: $[[ inputs.stage ]]
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "ğŸ¥ Executando verificaÃ§Ãµes finais de saÃºde..."
    - |
      # Configurar variÃ¡veis
      HEALTH_URL="$[[ inputs.health_check_url ]]"
      TIMEOUT="$[[ inputs.health_check_timeout ]]"

      if [ -z "$HEALTH_URL" ]; then
        echo "âš ï¸  URL de health check nÃ£o fornecida, pulando verificaÃ§Ã£o"
        exit 0
      fi

      echo "ğŸ” Verificando saÃºde da aplicaÃ§Ã£o em: $HEALTH_URL"

      # Executar health check
      for i in $(seq 1 $TIMEOUT); do
        echo "â³ Tentativa $i de $TIMEOUT..."

        # Fazer requisiÃ§Ã£o
        RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" "$HEALTH_URL" 2>/dev/null)
        HTTP_CODE=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*HTTPSTATUS://' | sed -e 's/;TIME.*//')
        TIME=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*TIME://')

        # Verificar status code
        if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
          echo "âœ… AplicaÃ§Ã£o saudÃ¡vel!"
          echo "ğŸ“Š Tempo de resposta: ${TIME}s"
          echo "ğŸ“Š Status code: $HTTP_CODE"

          # Verificar conteÃºdo da resposta
          BODY=$(echo "$RESPONSE" | sed -e 's/HTTPSTATUS.*//')
          if echo "$BODY" | jq . >/dev/null 2>&1; then
            echo "ğŸ“‹ Resposta JSON vÃ¡lida"
          fi

          exit 0
        fi

        if [ $i -eq $TIMEOUT ]; then
          echo "âŒ Health check falhou apÃ³s $TIMEOUT segundos"
          echo "ğŸ“Š Ãšltimo status code: $HTTP_CODE"
          echo "ğŸ“Š Ãšltimo tempo de resposta: ${TIME}s"

          if [ "$[[ inputs.rollback_on_failure ]]" = "true" ]; then
            echo "ğŸ”„ Executando rollback automÃ¡tico..."
            # Aqui seria implementado o rollback
            # Por exemplo: helm rollback, kubectl rollout undo, etc.
          fi

          exit 1
        fi

        sleep 1
      done
  dependencies:
    - kubernetes-deploy
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH && $[[ inputs.environment ]] != "development"
    - when: always