spec:
  inputs:
    stage:
      default: monitor
      description: "Stage onde o monitoramento serÃ¡ executado"
    monitoring_type:
      default: "basic"
      description: "Tipo de monitoramento: basic, advanced, full"
      options: ["basic", "advanced", "full"]
    alert_on_failure:
      default: true
      description: "Enviar alertas em caso de falhas"
    performance_baseline:
      default: 3000
      description: "Baseline de performance em ms (para Lighthouse)"
    accessibility_threshold:
      default: 90
      description: "Threshold mÃ­nimo de acessibilidade (%)"

# Componente de Monitoramento para AplicaÃ§Ãµes Web
# MÃ©tricas de performance, acessibilidade e disponibilidade

performance-monitoring:
  stage: $[[ inputs.stage ]]
  image: node:22
  script:
    - echo "ðŸ“Š Executando monitoramento de performance..."
    - |
      # Instalar lighthouse se necessÃ¡rio
      if ! command -v lighthouse &> /dev/null; then
        npm install -g lighthouse
      fi
    - |
      # Executar Lighthouse
      lighthouse $CI_ENVIRONMENT_URL \
        --output=json \
        --output-path=performance-report.json \
        --chrome-flags="--headless --no-sandbox --disable-gpu" \
        --only-categories=performance,accessibility,best-practices,seo \
        || echo "Lighthouse falhou, mas continuando..."
    - |
      # Analisar resultados
      if [ -f performance-report.json ]; then
        PERFORMANCE_SCORE=$(jq '.categories.performance.score * 100' performance-report.json)
        ACCESSIBILITY_SCORE=$(jq '.categories.accessibility.score * 100' performance-report.json)
        SEO_SCORE=$(jq '.categories.seo.score * 100' performance-report.json)

        echo "ðŸ“ˆ Scores obtidos:"
        echo "  Performance: ${PERFORMANCE_SCORE}%"
        echo "  Acessibilidade: ${ACCESSIBILITY_SCORE}%"
        echo "  SEO: ${SEO_SCORE}%"

        # Verificar thresholds
        if (( $(echo "$PERFORMANCE_SCORE < 80" | bc -l) )); then
          echo "âš ï¸ Performance abaixo do ideal: ${PERFORMANCE_SCORE}% (meta: 80%)"
          if [ "$[[ inputs.alert_on_failure ]]" = "true" ]; then
            echo "ðŸš¨ ALERTA: Performance degradada!"
          fi
        fi

        if (( $(echo "$ACCESSIBILITY_SCORE < $[[ inputs.accessibility_threshold ]]" | bc -l) )); then
          echo "âš ï¸ Acessibilidade abaixo do threshold: ${ACCESSIBILITY_SCORE}% (mÃ­nimo: $[[ inputs.accessibility_threshold ]]%)"
          if [ "$[[ inputs.alert_on_failure ]]" = "true" ]; then
            echo "ðŸš¨ ALERTA: Problemas de acessibilidade!"
          fi
        fi
      fi
    - |
      # Coletar mÃ©tricas de tempo de resposta
      echo "â±ï¸ Coletando mÃ©tricas de resposta..."
      for i in {1..5}; do
        RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" $CI_ENVIRONMENT_URL)
        echo "Resposta $i: ${RESPONSE_TIME}s" >> response-times.log
      done

      AVG_RESPONSE=$(awk '{sum+=$2} END {print sum/NR}' response-times.log)
      echo "Tempo mÃ©dio de resposta: ${AVG_RESPONSE}s"
  artifacts:
    paths:
      - performance-report.json
      - response-times.log
    expire_in: 1 week
  only:
    - main
    - develop
  environment:
    name: monitoring
  allow_failure: true

uptime-monitoring:
  stage: $[[ inputs.stage ]]
  image: curlimages/curl:latest
  script:
    - echo "ðŸ” Executando monitoramento de uptime..."
    - |
      # Teste de disponibilidade
      MAX_RETRIES=3
      RETRY_COUNT=0

      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        if curl -f -s --max-time 30 --retry 2 --retry-delay 5 $CI_ENVIRONMENT_URL > /dev/null; then
          echo "âœ… AplicaÃ§Ã£o estÃ¡ online"
          UPTIME_STATUS="online"
          break
        else
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "âŒ Tentativa $RETRY_COUNT falhou, tentando novamente..."
          sleep 10
        fi
      done

      if [ "$UPTIME_STATUS" != "online" ]; then
        echo "ðŸš¨ AplicaÃ§Ã£o estÃ¡ OFFLINE apÃ³s $MAX_RETRIES tentativas!"
        if [ "$[[ inputs.alert_on_failure ]]" = "true" ]; then
          echo "ðŸš¨ ALERTA: AplicaÃ§Ã£o indisponÃ­vel!"
          # Aqui seria integrado com sistema de alertas
        fi
        exit 1
      fi
    - |
      # Verificar certificados SSL se HTTPS
      if [[ $CI_ENVIRONMENT_URL == https://* ]]; then
        echo "ðŸ”’ Verificando certificado SSL..."
        CERT_INFO=$(curl -vI $CI_ENVIRONMENT_URL 2>&1 | grep "expire date")
        if [ -n "$CERT_INFO" ]; then
          echo "ðŸ“œ InformaÃ§Ãµes do certificado: $CERT_INFO"
        fi
      fi
  only:
    - main
    - develop
  environment:
    name: monitoring
  allow_failure: true

error-monitoring:
  stage: $[[ inputs.stage ]]
  image: node:22
  script:
    - echo "ðŸš¨ Verificando logs de erro..."
    - |
      # Verificar se hÃ¡ arquivos de log de erro
      if [ -d "logs" ]; then
        ERROR_COUNT=$(find logs -name "*.log" -exec grep -l "ERROR\|FATAL\|CRITICAL" {} \; | wc -l)
        if [ "$ERROR_COUNT" -gt "0" ]; then
          echo "âš ï¸ $ERROR_COUNT arquivo(s) de log contÃ©m erros"
          find logs -name "*.log" -exec grep -H "ERROR\|FATAL\|CRITICAL" {} \;
        else
          echo "âœ… Nenhum erro encontrado nos logs"
        fi
      else
        echo "â„¹ï¸ DiretÃ³rio de logs nÃ£o encontrado"
      fi
    - |
      # Verificar health checks da aplicaÃ§Ã£o
      if [ -n "$CI_ENVIRONMENT_URL" ]; then
        HEALTH_STATUS=$(curl -s $CI_ENVIRONMENT_URL/health 2>/dev/null || echo "unhealthy")
        if [ "$HEALTH_STATUS" != "healthy" ]; then
          echo "ðŸš¨ Health check falhou: $HEALTH_STATUS"
          if [ "$[[ inputs.alert_on_failure ]]" = "true" ]; then
            echo "ðŸš¨ ALERTA: Health check falhou!"
          fi
        else
          echo "âœ… Health check passou"
        fi
      fi
  dependencies:
    - performance-monitoring
    - uptime-monitoring
  only:
    - main
    - develop
  environment:
    name: monitoring
  allow_failure: true

metrics-collection:
  stage: $[[ inputs.stage ]]
  image: node:22
  script:
    - echo "ðŸ“Š Coletando mÃ©tricas avanÃ§adas..."
    - |
      # Coletar mÃ©tricas do Lighthouse detalhadas
      if [ -f performance-report.json ]; then
        echo "ðŸ“ˆ MÃ©tricas de Performance Detalhadas:"
        jq '.audits | to_entries[] | select(.key | contains("speed-index") or contains("first-contentful-paint") or contains("largest-contentful-paint")) | "\(.key): \(.value.displayValue)"' performance-report.json

        echo "ðŸ“± MÃ©tricas de Core Web Vitals:"
        jq '.audits | to_entries[] | select(.key | contains("cumulative-layout-shift") or contains("total-blocking-time") or contains("max-potential-fid")) | "\(.key): \(.value.displayValue)"' performance-report.json
      fi
    - |
      # Gerar relatÃ³rio consolidado
      cat > monitoring-report.json << EOF
      {
        "timestamp": "$(date -Iseconds)",
        "environment": "$CI_ENVIRONMENT_NAME",
        "url": "$CI_ENVIRONMENT_URL",
        "pipeline": "$CI_PIPELINE_ID",
        "commit": "$CI_COMMIT_SHA",
        "metrics": {
          "performance_score": $(jq '.categories.performance.score * 100' performance-report.json 2>/dev/null || echo "null"),
          "accessibility_score": $(jq '.categories.accessibility.score * 100' performance-report.json 2>/dev/null || echo "null"),
          "uptime_status": "$UPTIME_STATUS",
          "response_time_avg": $(cat response-times.log 2>/dev/null | awk '{sum+=$2} END {print sum/NR}' || echo "null")
        }
      }
      EOF
      echo "âœ… RelatÃ³rio de monitoramento gerado"
  artifacts:
    paths:
      - monitoring-report.json
    expire_in: 1 month
  dependencies:
    - performance-monitoring
    - uptime-monitoring
    - error-monitoring
  only:
    - main
    - develop
  environment:
    name: monitoring
  when: always