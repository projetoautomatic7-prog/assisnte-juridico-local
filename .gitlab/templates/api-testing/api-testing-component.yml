spec:
  inputs:
    stage:
      default: test
      description: "Stage onde os testes de API ser√£o executados"
    api_base_url:
      description: "URL base da API para testes"
    api_endpoints:
      description: "Lista de endpoints para testar (separados por v√≠rgula)"
    test_type:
      default: "smoke"
      description: "Tipo de teste: smoke, integration, load, security"
      options: ["smoke", "integration", "load", "security"]
    auth_token:
      description: "Token de autentica√ß√£o para API"
    auth_type:
      default: "bearer"
      description: "Tipo de autentica√ß√£o: bearer, basic, api-key"
      options: ["bearer", "basic", "api-key"]
    timeout:
      default: "30"
      description: "Timeout em segundos para cada requisi√ß√£o"
    retries:
      default: "3"
      description: "N√∫mero de tentativas para cada endpoint"
    expected_status_codes:
      default: "200,201,204"
      description: "C√≥digos de status esperados (separados por v√≠rgula)"
    performance_threshold:
      default: "5000"
      description: "Threshold de performance em ms (para testes de carga)"
    security_headers:
      default: true
      description: "Verificar headers de seguran√ßa"
    generate_report:
      default: true
      description: "Gerar relat√≥rio de testes"

# Componente de Testes de API para Aplica√ß√µes Jur√≠dicas
# Suporte a testes smoke, integra√ß√£o, carga e seguran√ßa

api-smoke-test:
  stage: $[[ inputs.stage ]]
  image: node:18-alpine
  before_script:
    - apk add --no-cache curl jq
    - npm install -g newman
  script:
    - echo "üß™ Executando testes smoke da API..."
    - |
      # Configurar vari√°veis
      BASE_URL="$[[ inputs.api_base_url ]]"
      ENDPOINTS="$[[ inputs.api_endpoints ]]"
      AUTH_TOKEN="$[[ inputs.auth_token ]]"
      AUTH_TYPE="$[[ inputs.auth_type ]]"
      TIMEOUT="$[[ inputs.timeout ]]"
      RETRIES="$[[ inputs.retries ]]"
      EXPECTED_CODES="$[[ inputs.expected_status_codes ]]"

      # Criar cole√ß√£o Postman
      COLLECTION_FILE="api-smoke-tests.postman_collection.json"
      cat > "$COLLECTION_FILE" << EOF
      {
        "info": {
          "name": "API Smoke Tests - Assistente Jur√≠dico",
          "description": "Testes automatizados de fuma√ßa para API jur√≠dica"
        },
        "item": [
      EOF

      # Adicionar endpoints √† cole√ß√£o
      IFS=',' read -ra ENDPOINT_ARRAY <<< "$ENDPOINTS"
      for endpoint in "${ENDPOINT_ARRAY[@]}"; do
        endpoint=$(echo "$endpoint" | xargs)  # Trim whitespace

        # Determinar m√©todo HTTP baseado no endpoint
        if [[ "$endpoint" == *"create"* ]] || [[ "$endpoint" == *"add"* ]]; then
          METHOD="POST"
        elif [[ "$endpoint" == *"update"* ]] || [[ "$endpoint" == *"edit"* ]]; then
          METHOD="PUT"
        elif [[ "$endpoint" == *"delete"* ]] || [[ "$endpoint" == *"remove"* ]]; then
          METHOD="DELETE"
        else
          METHOD="GET"
        fi

        # Adicionar item √† cole√ß√£o
        cat >> "$COLLECTION_FILE" << EOF
          {
            "name": "Test $METHOD $endpoint",
            "request": {
              "method": "$METHOD",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
      EOF

        # Adicionar autentica√ß√£o
        case "$AUTH_TYPE" in
          bearer)
            if [ -n "$AUTH_TOKEN" ]; then
              cat >> "$COLLECTION_FILE" << EOF
                ,
                {
                  "key": "Authorization",
                  "value": "Bearer $AUTH_TOKEN"
                }
      EOF
            fi
            ;;
          basic)
            if [ -n "$AUTH_TOKEN" ]; then
              cat >> "$COLLECTION_FILE" << EOF
                ,
                {
                  "key": "Authorization",
                  "value": "Basic $AUTH_TOKEN"
                }
      EOF
            fi
            ;;
          api-key)
            if [ -n "$AUTH_TOKEN" ]; then
              cat >> "$COLLECTION_FILE" << EOF
                ,
                {
                  "key": "X-API-Key",
                  "value": "$AUTH_TOKEN"
                }
      EOF
            fi
            ;;
        esac

        # Completar request
        cat >> "$COLLECTION_FILE" << EOF
              ],
              "url": {
                "raw": "{{base_url}}$endpoint",
                "host": ["{{base_url}}"],
                "path": ["$endpoint"]
              },
              "description": "Smoke test for $endpoint"
            },
            "response": []
          },
      EOF
      done

      # Fechar cole√ß√£o
      sed -i '$ s/,$//' "$COLLECTION_FILE"  # Remove √∫ltima v√≠rgula
      cat >> "$COLLECTION_FILE" << EOF
        ],
        "variable": [
          {
            "key": "base_url",
            "value": "$BASE_URL"
          }
        ]
      }
      EOF

      # Executar testes com Newman
      echo "üöÄ Executando cole√ß√£o Postman..."
      newman run "$COLLECTION_FILE" \
        --timeout $TIMEOUT \
        --delay-request 1000 \
        --reporters cli,json \
        --reporter-json-export "api-smoke-results.json"

      # Verificar resultados
      SUCCESS_COUNT=$(jq '.run.stats.assertions.total' api-smoke-results.json)
      FAILURE_COUNT=$(jq '.run.stats.assertions.failed' api-smoke-results.json)

      echo "üìä Resultados dos testes smoke:"
      echo "‚úÖ Sucessos: $SUCCESS_COUNT"
      echo "‚ùå Falhas: $FAILURE_COUNT"

      if [ "$FAILURE_COUNT" -gt 0 ]; then
        echo "‚ùå Alguns testes smoke falharam"
        exit 1
      fi

      echo "‚úÖ Todos os testes smoke passaram!"
  artifacts:
    reports:
      junit: api-smoke-results.json
    expire_in: 1 week
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH && $[[ inputs.test_type ]] == "smoke"
    - when: always

api-integration-test:
  stage: $[[ inputs.stage ]]
  image: node:18-alpine
  before_script:
    - apk add --no-cache curl jq
    - npm install -g artillery
  script:
    - echo "üîó Executando testes de integra√ß√£o da API..."
    - |
      # Configurar vari√°veis
      BASE_URL="$[[ inputs.api_base_url ]]"
      ENDPOINTS="$[[ inputs.api_endpoints ]]"
      AUTH_TOKEN="$[[ inputs.auth_token ]]"
      AUTH_TYPE="$[[ inputs.auth_type ]]"

      # Criar script Artillery
      ARTILLERY_FILE="api-integration-test.yml"
      cat > "$ARTILLERY_FILE" << EOF
      config:
        target: '$BASE_URL'
        phases:
          - duration: 60
            arrivalRate: 5
            name: Warm up
          - duration: 120
            arrivalRate: 10
            name: Load test
        defaults:
          headers:
            Content-Type: 'application/json'
      EOF

      # Adicionar autentica√ß√£o
      case "$AUTH_TYPE" in
        bearer)
          if [ -n "$AUTH_TOKEN" ]; then
            cat >> "$ARTILLERY_FILE" << EOF
            Authorization: 'Bearer $AUTH_TOKEN'
      EOF
          fi
          ;;
        basic)
          if [ -n "$AUTH_TOKEN" ]; then
            cat >> "$ARTILLERY_FILE" << EOF
            Authorization: 'Basic $AUTH_TOKEN'
      EOF
          fi
          ;;
        api-key)
          if [ -n "$AUTH_TOKEN" ]; then
            cat >> "$ARTILLERY_FILE" << EOF
            X-API-Key: '$AUTH_TOKEN'
      EOF
          fi
          ;;
      esac

      # Adicionar cen√°rios de teste
      cat >> "$ARTILLERY_FILE" << EOF
      scenarios:
      EOF

      # Adicionar endpoints aos cen√°rios
      IFS=',' read -ra ENDPOINT_ARRAY <<< "$ENDPOINTS"
      for endpoint in "${ENDPOINT_ARRAY[@]}"; do
        endpoint=$(echo "$endpoint" | xargs)

        # Determinar m√©todo baseado no endpoint
        if [[ "$endpoint" == *"create"* ]] || [[ "$endpoint" == *"add"* ]]; then
          METHOD="POST"
          PAYLOAD='{"test": "integration"}'
        elif [[ "$endpoint" == *"update"* ]] || [[ "$endpoint" == *"edit"* ]]; then
          METHOD="PUT"
          PAYLOAD='{"test": "integration", "id": "123"}'
        elif [[ "$endpoint" == *"delete"* ]] || [[ "$endpoint" == *"remove"* ]]; then
          METHOD="DELETE"
          PAYLOAD=""
        else
          METHOD="GET"
          PAYLOAD=""
        fi

        cat >> "$ARTILLERY_FILE" << EOF
        - name: 'Test $METHOD $endpoint'
          flow:
          - $METHOD:
              url: '$endpoint'
      EOF

        if [ -n "$PAYLOAD" ]; then
          cat >> "$ARTILLERY_FILE" << EOF
              json: $PAYLOAD
      EOF
        fi

        cat >> "$ARTILLERY_FILE" << EOF
              expect:
                - statusCode: [200, 201, 204]
              capture:
                - json: '$.id'
                  as: 'resourceId'
      EOF
      done

      # Executar testes
      echo "üöÄ Executando testes de integra√ß√£o..."
      artillery run "$ARTILLERY_FILE" --output "api-integration-results.json"

      # Verificar resultados
      REQUESTS=$(jq '.aggregate.counters."http.requests"' api-integration-results.json)
      ERRORS=$(jq '.aggregate.counters."errors.ETIMEDOUT"' api-integration-results.json 2>/dev/null || echo 0)
      RESPONSE_TIME=$(jq '.aggregate.summaries."http.response_time".median' api-integration-results.json)

      echo "üìä Resultados dos testes de integra√ß√£o:"
      echo "üì° Requisi√ß√µes: $REQUESTS"
      echo "‚ö†Ô∏è  Erros: $ERRORS"
      echo "‚è±Ô∏è  Tempo m√©dio de resposta: ${RESPONSE_TIME}ms"

      if [ "$ERRORS" -gt 0 ]; then
        echo "‚ùå Testes de integra√ß√£o falharam com erros"
        exit 1
      fi

      echo "‚úÖ Testes de integra√ß√£o conclu√≠dos!"
  artifacts:
    reports:
      junit: api-integration-results.json
    expire_in: 1 week
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH && $[[ inputs.test_type ]] == "integration"
    - when: always

api-security-test:
  stage: $[[ inputs.stage ]]
  image: node:18-alpine
  before_script:
    - apk add --no-cache curl jq nmap
    - npm install -g retire
  script:
    - echo "üîí Executando testes de seguran√ßa da API..."
    - |
      # Configurar vari√°veis
      BASE_URL="$[[ inputs.api_base_url ]]"
      ENDPOINTS="$[[ inputs.api_endpoints ]]"

      # Extrair host da URL
      HOST=$(echo "$BASE_URL" | sed 's|https://||' | sed 's|http://||' | cut -d'/' -f1)

      echo "üîç Executando verifica√ß√µes de seguran√ßa..."

      # Verificar headers de seguran√ßa
      if [ "$[[ inputs.security_headers ]]" = "true" ]; then
        echo "üõ°Ô∏è  Verificando headers de seguran√ßa..."

        # Testar endpoint principal
        RESPONSE=$(curl -I -s "$BASE_URL" 2>/dev/null)

        # Verificar headers cr√≠ticos
        SECURITY_HEADERS=(
          "Strict-Transport-Security"
          "X-Content-Type-Options"
          "X-Frame-Options"
          "X-XSS-Protection"
          "Content-Security-Policy"
          "Referrer-Policy"
        )

        MISSING_HEADERS=()
        for header in "${SECURITY_HEADERS[@]}"; do
          if ! echo "$RESPONSE" | grep -i "$header:" >/dev/null; then
            MISSING_HEADERS+=("$header")
          fi
        done

        if [ ${#MISSING_HEADERS[@]} -gt 0 ]; then
          echo "‚ö†Ô∏è  Headers de seguran√ßa ausentes:"
          printf '  - %s\n' "${MISSING_HEADERS[@]}"
        else
          echo "‚úÖ Todos os headers de seguran√ßa est√£o presentes"
        fi
      fi

      # Verificar vulnerabilidades em depend√™ncias
      echo "üì¶ Verificando vulnerabilidades em depend√™ncias..."
      if [ -f "package.json" ]; then
        npm audit --audit-level moderate --json > npm-audit-results.json 2>/dev/null || true

        VULNERABILITIES=$(jq '.metadata.vulnerabilities.total // 0' npm-audit-results.json 2>/dev/null || echo 0)

        if [ "$VULNERABILITIES" -gt 0 ]; then
          echo "‚ö†Ô∏è  Encontradas $VULNERABILITIES vulnerabilidades em depend√™ncias"
          npm audit --audit-level moderate
        else
          echo "‚úÖ Nenhuma vulnerabilidade cr√≠tica encontrada"
        fi
      fi

      # Testar inje√ß√£o b√°sica
      echo "üíâ Testando vulnerabilidades de inje√ß√£o..."
      IFS=',' read -ra ENDPOINT_ARRAY <<< "$ENDPOINTS"
      for endpoint in "${ENDPOINT_ARRAY[@]}"; do
        endpoint=$(echo "$endpoint" | xargs)

        # Testar SQL injection b√°sica
        SQL_PAYLOAD='{"test": "1 OR 1=1"}'
        RESPONSE=$(curl -s -X POST "$BASE_URL$endpoint" \
          -H "Content-Type: application/json" \
          -d "$SQL_PAYLOAD" 2>/dev/null)

        if echo "$RESPONSE" | grep -i "error\|exception\|sql" >/dev/null; then
          echo "‚ö†Ô∏è  Poss√≠vel vulnerabilidade SQLi detectada em $endpoint"
        fi

        # Testar XSS b√°sico
        XSS_PAYLOAD='{"test": "<script>alert(1)</script>"}'
        RESPONSE=$(curl -s -X POST "$BASE_URL$endpoint" \
          -H "Content-Type: application/json" \
          -d "$XSS_PAYLOAD" 2>/dev/null)

        if echo "$RESPONSE" | grep -i "<script>" >/dev/null; then
          echo "‚ö†Ô∏è  Poss√≠vel vulnerabilidade XSS detectada em $endpoint"
        fi
      done

      # Verificar exposi√ß√£o de informa√ß√µes sens√≠veis
      echo "üîç Verificando exposi√ß√£o de informa√ß√µes..."
      SENSITIVE_PATTERNS=(
        "password"
        "secret"
        "key"
        "token"
        "credential"
        "private"
      )

      for endpoint in "${ENDPOINT_ARRAY[@]}"; do
        endpoint=$(echo "$endpoint" | xargs)
        RESPONSE=$(curl -s "$BASE_URL$endpoint" 2>/dev/null)

        for pattern in "${SENSITIVE_PATTERNS[@]}"; do
          if echo "$RESPONSE" | grep -i "$pattern" >/dev/null; then
            echo "‚ö†Ô∏è  Poss√≠vel exposi√ß√£o de informa√ß√£o sens√≠vel ($pattern) em $endpoint"
          fi
        done
      done

      echo "‚úÖ Verifica√ß√µes de seguran√ßa conclu√≠das!"
  artifacts:
    reports:
      junit: api-security-results.json
    expire_in: 1 week
  allow_failure: false
  rules:
    - if: $CI_COMMIT_BRANCH && $[[ inputs.test_type ]] == "security"
    - when: always