# üîç Relat√≥rio de Revis√£o: Atomicidade Redis e Valida√ß√£o Zod

**Data**: 6 de dezembro de 2025  
**Arquivo analisado**: `api/agents.ts`  
**Revisor**: GitHub Copilot  
**Status**: ‚ö†Ô∏è PROBLEMAS CR√çTICOS IDENTIFICADOS

---

## üö® Problemas Cr√≠ticos Encontrados

### 1. ‚ùå RACE CONDITION em `saveAutoGeneratedMinuta()` (Linhas 990-1045)

#### **C√≥digo Atual (PROBLEMA)**:
```typescript
async function saveAutoGeneratedMinuta(task: AgentTask, result: TaskResult): Promise<void> {
  // ...
  try {
    const redis = getRedisOrNull();
    if (!redis) {
      logger.warn("No Redis available to save auto-generated minuta");
      return;
    }

    // ‚ùå RACE CONDITION: GET e SET n√£o s√£o at√¥micos
    const existingMinutas = (await redis.get("minutas")) as unknown[] | null;
    const currentMinutas = existingMinutas ?? [];

    // ‚ö†Ô∏è Se dois agentes executarem simultaneamente, uma minuta pode ser perdida
    await redis.set("minutas", [...currentMinutas, minuta]);

    logger.info("Auto-created minuta", {
      id: minuta.id,
      titulo: minuta.titulo,
      agentId: task.agentId,
    });
  } catch (error) {
    logger.error("Failed to save auto-generated minuta to Redis", error);
  }
}
```

#### **Problema Identificado**:
- **GET ‚Üí SET n√£o √© at√¥mico**: Se dois agentes executarem `saveAutoGeneratedMinuta` ao mesmo tempo:
  1. Agente A l√™ `minutas` (array com 10 itens)
  2. Agente B l√™ `minutas` (array com 10 itens)
  3. Agente A adiciona minuta A e salva (11 itens)
  4. Agente B adiciona minuta B e salva (11 itens) - **SOBRESCREVE o array do Agente A!**
  5. **Resultado**: Minuta A √© perdida ‚ùå

#### **Solu√ß√£o Recomendada**:

**Op√ß√£o 1: Usar RPUSH (comando at√¥mico do Redis)**
```typescript
async function saveAutoGeneratedMinuta(task: AgentTask, result: TaskResult): Promise<void> {
  if (task.type !== AgentTaskType.DRAFT_PETITION || !result.draft) return;

  const data = task.data as Record<string, unknown>;

  const documentType = getStringValue(data.documentType, "Peti√ß√£o");
  const processNumber = getStringValue(data.processNumber, "Novo");
  const processId = getStringValue(data.processId) || undefined;
  const expedienteId = getStringValue(data.expedienteId) || undefined;

  const minuta = {
    id: randomUUID(),
    titulo: `[Agente] ${documentType} - ${processNumber}`,
    processId,
    tipo: determineMinutaTipo(documentType),
    conteudo: String(result.draft),
    status: "pendente-revisao" as const,
    criadoEm: new Date().toISOString(),
    atualizadoEm: new Date().toISOString(),
    autor: "Agente IA",
    criadoPorAgente: true,
    agenteId: task.agentId,
    expedienteId,
    variaveis: {},
  };

  try {
    const redis = getRedisOrNull();
    if (!redis) {
      logger.warn("No Redis available to save auto-generated minuta");
      return;
    }

    // ‚úÖ SOLU√á√ÉO: Usar lista Redis com RPUSH (comando at√¥mico)
    // Salvar cada minuta com chave √∫nica
    await redis.set(`minuta:${minuta.id}`, minuta);
    
    // Adicionar ID √† lista de minutas (opera√ß√£o at√¥mica)
    await redis.rpush("minutas:ids", minuta.id);
    
    // Opcional: adicionar √≠ndice por processo
    if (processId) {
      await redis.rpush(`minutas:process:${processId}`, minuta.id);
    }

    logger.info("Auto-created minuta", {
      id: minuta.id,
      titulo: minuta.titulo,
      agentId: task.agentId,
    });
  } catch (error) {
    logger.error("Failed to save auto-generated minuta to Redis", error);
    // ‚ö†Ô∏è PROBLEMA: N√£o h√° rollback aqui - ver se√ß√£o 2
  }
}
```

**Op√ß√£o 2: Usar transa√ß√£o Redis (MULTI/EXEC)**
```typescript
async function saveAutoGeneratedMinuta(task: AgentTask, result: TaskResult): Promise<void> {
  // ... (c√≥digo de prepara√ß√£o da minuta igual)

  try {
    const redis = getRedisOrNull();
    if (!redis) {
      logger.warn("No Redis available to save auto-generated minuta");
      return;
    }

    // ‚úÖ Usar pipeline/transa√ß√£o para garantir atomicidade
    const pipeline = redis.pipeline();
    
    // Adicionar comandos ao pipeline
    pipeline.get("minutas");
    pipeline.set("minutas", (prev) => {
      const current = (prev as unknown[] | null) ?? [];
      return [...current, minuta];
    });
    
    // Executar atomicamente
    await pipeline.exec();

    logger.info("Auto-created minuta", {
      id: minuta.id,
      titulo: minuta.titulo,
      agentId: task.agentId,
    });
  } catch (error) {
    logger.error("Failed to save auto-generated minuta to Redis", error);
  }
}
```

---

### 2. ‚ùå SEM ROLLBACK em caso de falha do trigger de agentes (Linhas 1050-1080)

#### **C√≥digo Atual (PROBLEMA)**:
```typescript
async function processQueueTask(
  task: AgentTask,
  agents: Agent[],
  taskQueue: AgentTask[]
): Promise<ProcessQueueTaskResult> {
  // ...

  try {
    logger.info(`Processing task ${task.id} for ${agent.name}`);
    const result = await processTaskWithAI(task, agent);

    // ‚úÖ Tarefa processada com sucesso
    task.status = TaskStatus.COMPLETED;
    task.completedAt = new Date().toISOString();
    task.result = result;

    // ‚ö†Ô∏è A√ß√µes encadeadas (pode falhar)
    processChainedActions(task, result, taskQueue);
    
    // ‚ö†Ô∏è Salvamento de minuta (pode falhar)
    await saveAutoGeneratedMinuta(task, result);
    // ‚ùå Se falhar aqui, a tarefa j√° foi marcada como COMPLETED
    // mas a minuta n√£o foi salva - INCONSIST√äNCIA!

    return { taskId: task.id, status: "completed" };
  } catch (error) {
    logger.error(`Error processing task ${task.id}`, error);
    task.status = TaskStatus.FAILED;
    task.error = error instanceof Error ? error.message : "Unknown error";

    return { taskId: task.id, status: "failed", error: task.error };
  }
}
```

#### **Problema Identificado**:
1. Tarefa √© processada com IA ‚úÖ
2. Status muda para `COMPLETED` ‚úÖ
3. `processChainedActions()` executa (pode falhar) ‚ö†Ô∏è
4. `saveAutoGeneratedMinuta()` executa (pode falhar) ‚ö†Ô∏è
5. **Se 3 ou 4 falhar**: Tarefa est√° `COMPLETED` mas a minuta n√£o existe no Redis ‚ùå

#### **Solu√ß√£o Recomendada**:

```typescript
async function processQueueTask(
  task: AgentTask,
  agents: Agent[],
  taskQueue: AgentTask[]
): Promise<ProcessQueueTaskResult> {
  const agent = agents.find((a) => a.id === task.agentId);

  if (!agent) {
    logger.info(`Skipping task ${task.id} - agent not found`);
    return { taskId: task.id, status: "failed", error: "Agent not found" };
  }

  if (!canProcessTask(task, agent)) {
    logger.info(`Skipping task ${task.id} - agent disabled`);
    return { taskId: task.id, status: "failed", error: "Agent disabled" };
  }

  // ‚úÖ Vari√°veis para rollback
  let aiResult: TaskResult | null = null;
  let minutaSaved = false;
  let chainedActionsProcessed = false;

  try {
    logger.info(`Processing task ${task.id} for ${agent.name}`);
    
    // Passo 1: Processar com IA
    aiResult = await processTaskWithAI(task, agent);

    // Passo 2: Salvar minuta ANTES de marcar como completed
    try {
      await saveAutoGeneratedMinuta(task, aiResult);
      minutaSaved = true;
    } catch (minutaError) {
      logger.error(`Failed to save minuta for task ${task.id}`, minutaError);
      // ‚ö†Ô∏è Decis√£o: minuta √© cr√≠tica? Se sim, falhar tarefa inteira
      throw new Error(`Critical: Failed to save minuta - ${minutaError instanceof Error ? minutaError.message : 'Unknown error'}`);
    }

    // Passo 3: Processar a√ß√µes encadeadas
    try {
      processChainedActions(task, aiResult, taskQueue);
      chainedActionsProcessed = true;
    } catch (chainError) {
      logger.warn(`Failed chained actions for task ${task.id}`, chainError);
      // ‚ö†Ô∏è A√ß√µes encadeadas s√£o menos cr√≠ticas - apenas logar
    }

    // ‚úÖ TUDO SUCESSO: Marcar como completed
    task.status = TaskStatus.COMPLETED;
    task.completedAt = new Date().toISOString();
    task.result = aiResult;

    return { 
      taskId: task.id, 
      status: "completed",
      metadata: {
        minutaSaved,
        chainedActionsProcessed
      }
    };

  } catch (error) {
    logger.error(`Error processing task ${task.id}`, error);
    
    // ‚ùå ROLLBACK: Se algo falhou, reverter estados
    if (minutaSaved) {
      // TODO: Implementar rollback da minuta se necess√°rio
      logger.warn(`Task ${task.id} failed but minuta was saved - manual cleanup may be needed`);
    }

    task.status = TaskStatus.FAILED;
    task.error = error instanceof Error ? error.message : "Unknown error";

    return { taskId: task.id, status: "failed", error: task.error };
  }
}
```

---

### 3. ‚ö†Ô∏è VALIDA√á√ÉO ZOD: `createMinutaFromAgentTask` n√£o existe no c√≥digo atual

#### **Status**:
- ‚ùå A fun√ß√£o `createMinutaFromAgentTask` mencionada no relat√≥rio do CodeRabbit **N√ÉO EXISTE** no c√≥digo atual
- ‚úÖ A fun√ß√£o equivalente √© `saveAutoGeneratedMinuta()` que **N√ÉO retorna null**
- ‚úÖ Retorna `Promise<void>`, ent√£o n√£o h√° problema de tratamento de null

#### **C√≥digo Atual**:
```typescript
async function saveAutoGeneratedMinuta(task: AgentTask, result: TaskResult): Promise<void> {
  if (task.type !== AgentTaskType.DRAFT_PETITION || !result.draft) return; // ‚úÖ Early return
  
  // ... resto do c√≥digo
}
```

#### **Conclus√£o**:
- ‚úÖ **N√£o h√° problema de tratamento de null** no c√≥digo atual
- ‚ö†Ô∏è Mas pode ser que `api/lib/minuta-service-backend.ts` exista em uma PR n√£o mergeada
- üìã **Recomenda√ß√£o**: Quando `createMinutaFromAgentTask` for introduzida, garantir:
  ```typescript
  const minuta = await createMinutaFromAgentTask(task, result);
  if (!minuta) {
    logger.warn(`No minuta created for task ${task.id}`);
    // Decidir: isso √© um erro cr√≠tico ou n√£o?
    return; // ou throw new Error()
  }
  // Continuar processamento com minuta v√°lida
  ```

---

## üìä Resumo de Problemas

| # | Problema | Severidade | Status | Localiza√ß√£o |
|---|----------|------------|--------|-------------|
| 1 | Race condition em `saveAutoGeneratedMinuta` (GET‚ÜíSET n√£o at√¥mico) | üî¥ **CR√çTICO** | ‚ùå N√£o corrigido | Linhas 1024-1030 |
| 2 | Sem rollback se `saveAutoGeneratedMinuta` falhar ap√≥s marcar tarefa como completed | üî¥ **CR√çTICO** | ‚ùå N√£o corrigido | Linhas 1062-1071 |
| 3 | Fun√ß√£o `createMinutaFromAgentTask` n√£o existe (falso positivo CodeRabbit) | üü¢ **INFO** | ‚úÖ N/A | - |

---

## ‚úÖ Checklist de Corre√ß√µes Necess√°rias

### Atomicidade Redis

- [ ] **Corrigir `saveAutoGeneratedMinuta`**:
  - [ ] Op√ß√£o 1: Migrar para `RPUSH` (lista Redis)
  - [ ] Op√ß√£o 2: Usar transa√ß√£o `MULTI/EXEC`
  - [ ] Op√ß√£o 3: Usar `SETNX` com lock distribu√≠do

- [ ] **Adicionar rollback em `processQueueTask`**:
  - [ ] Salvar minuta ANTES de marcar tarefa como completed
  - [ ] Implementar try-catch espec√≠fico para `saveAutoGeneratedMinuta`
  - [ ] Adicionar metadata sobre sucesso de cada passo
  - [ ] Logar warnings se rollback parcial for necess√°rio

- [ ] **Testes de Concorr√™ncia**:
  - [ ] Criar teste E2E que simula 10 agentes salvando minutas simultaneamente
  - [ ] Verificar que nenhuma minuta √© perdida
  - [ ] Validar integridade do array/lista de minutas

### Valida√ß√£o e Tratamento de Erros

- [ ] **Se `minuta-service-backend.ts` for adicionado**:
  - [ ] Garantir que `createMinutaFromAgentTask` retorna tipo `Minuta | null`
  - [ ] Adicionar valida√ß√£o Zod no schema de retorno
  - [ ] Todos os chamadores devem verificar `if (!minuta)` antes de usar

- [ ] **Melhorar logging**:
  - [ ] Adicionar trace IDs para correlacionar logs
  - [ ] Logar timestamps precisos de cada opera√ß√£o
  - [ ] Implementar m√©tricas de dura√ß√£o de opera√ß√µes cr√≠ticas

---

## üéØ Prioridade de Implementa√ß√£o

### üî• URGENTE (Fazer HOJE)
1. Corrigir race condition em `saveAutoGeneratedMinuta`
2. Adicionar rollback em `processQueueTask`

### üìÖ IMPORTANTE (Fazer esta semana)
3. Criar testes de concorr√™ncia
4. Implementar m√©tricas de performance
5. Adicionar trace IDs para debugging

### üìã BACKLOG (Pr√≥xima sprint)
6. Revisar todas opera√ß√µes Redis no projeto
7. Implementar retry com backoff exponencial
8. Adicionar circuit breaker para opera√ß√µes cr√≠ticas

---

## üîó Refer√™ncias

- [Upstash Redis - Atomic Operations](https://upstash.com/docs/redis/features/atomicoperations)
- [Redis Transactions (MULTI/EXEC)](https://redis.io/docs/manual/transactions/)
- [Redis Lists (RPUSH/LPUSH)](https://redis.io/docs/data-types/lists/)
- [Pattern: Optimistic Locking with Redis](https://redis.io/docs/manual/patterns/distributed-locks/)

---

**Pr√≥ximo passo**: Implementar as corre√ß√µes usando `multi_replace_string_in_file` em `api/agents.ts`
