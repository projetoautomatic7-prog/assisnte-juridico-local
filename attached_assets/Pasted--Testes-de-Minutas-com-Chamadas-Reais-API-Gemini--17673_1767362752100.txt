"""
Testes de Minutas com Chamadas Reais √† API Gemini
=================================================

Testa o workflow completo de reda√ß√£o de minutas usando a API real do Gemini.
"""

import asyncio
import os
import sys

import pytest

# Adicionar diret√≥rio pai ao path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

RUN_REAL = os.getenv("RUN_REAL_GEMINI_TESTS") == "1"
HAS_KEY = bool(os.getenv("GOOGLE_API_KEY") or os.getenv("GEMINI_API_KEY"))

pytestmark = pytest.mark.skipif(
    not (RUN_REAL and HAS_KEY),
    reason=(
        "Testes reais do Gemini s√£o opt-in. Defina RUN_REAL_GEMINI_TESTS=1 e GOOGLE_API_KEY (ou GEMINI_API_KEY)."
    ),
)


class TestAIMinutaCommandsReal:
    """Testes com chamadas reais ao Gemini para comandos de IA"""

    @pytest.fixture
    def ai_commands(self):
        """Inicializa o m√≥dulo de comandos de IA"""
        from lib.ai_commands import AIMinutaCommands

        return AIMinutaCommands()

    @pytest.mark.asyncio
    async def test_continuar_texto_real(self, ai_commands):
        """Testa continua√ß√£o de texto com API real"""
        texto_inicial = """
        EXCELENT√çSSIMO(A) SENHOR(A) DOUTOR(A) JUIZ(A) DE DIREITO DA VARA C√çVEL DA COMARCA DE DIVIN√ìPOLIS/MG

        PROCESSO N¬∫: 0001234-56.2025.8.13.0223

        FULANO DE TAL, j√° qualificado nos autos, vem, respeitosamente, √† presen√ßa de Vossa Excel√™ncia,
        por seu advogado infra-assinado, com fundamento no artigo 319 do C√≥digo de Processo Civil,
        """

        resultado = ""
        async for chunk in ai_commands.continuar(texto_inicial):
            resultado += chunk
            print(chunk, end="", flush=True)

        print("\n")  # Nova linha ap√≥s streaming

        # Verifica√ß√µes
        assert len(resultado) > 50, "Continua√ß√£o deve ter conte√∫do substancial"
        assert resultado.strip(), "Resultado n√£o pode estar vazio"
        print(f"‚úÖ Continua√ß√£o gerada com {len(resultado)} caracteres")

    @pytest.mark.asyncio
    async def test_expandir_texto_real(self, ai_commands):
        """Testa expans√£o de texto com API real"""
        texto_curto = (
            "O autor sofreu danos morais devido √† conduta il√≠cita da empresa r√©."
        )

        resultado = ""
        async for chunk in ai_commands.expandir(texto_curto):
            resultado += chunk

        # Verifica√ß√µes
        assert (
            len(resultado) > len(texto_curto) * 2
        ), "Texto expandido deve ser significativamente maior"
        print(
            f"‚úÖ Texto expandido de {len(texto_curto)} para {len(resultado)} caracteres"
        )

    @pytest.mark.asyncio
    async def test_revisar_texto_real(self, ai_commands):
        """Testa revis√£o de texto com API real"""
        texto_com_erros = """
        O requerente, vem respeitosamente perante vossa excel√™ncia, requerer a procedencia
        da a√ß√£o, haja visto que o requerido n√£o cumpriu com suas obriga√ß√µes contratuais,
        causando prejuisos ao autor.
        """

        resultado = ""
        async for chunk in ai_commands.revisar(texto_com_erros):
            resultado += chunk

        # Verifica√ß√µes
        assert len(resultado) > 50, "Revis√£o deve ter conte√∫do"
        assert (
            "preju√≠z" in resultado.lower() or "danos" in resultado.lower()
        ), "Deve corrigir ou melhorar o texto"
        print(f"‚úÖ Texto revisado com {len(resultado)} caracteres")

    @pytest.mark.asyncio
    async def test_formalizar_texto_real(self, ai_commands):
        """Testa formaliza√ß√£o de texto com API real"""
        texto_informal = """
        O cara n√£o pagou a conta. Ele deve muito dinheiro e n√£o quer pagar.
        A gente precisa cobrar ele na justi√ßa porque ele t√° errado.
        """

        resultado = ""
        async for chunk in ai_commands.formalizar(texto_informal):
            resultado += chunk

        # Verifica√ß√µes
        assert len(resultado) > 50, "Formaliza√ß√£o deve ter conte√∫do"
        # Verificar se usa linguagem mais formal
        termos_formais = [
            "devedor",
            "credor",
            "obriga√ß√£o",
            "adimplemento",
            "inadimplemento",
            "requerido",
            "autor",
            "r√©u",
            "d√©bito",
            "cr√©dito",
        ]
        possui_termo_formal = any(
            termo in resultado.lower() for termo in termos_formais
        )
        print(f"‚úÖ Texto formalizado com {len(resultado)} caracteres")
        print(f"   Cont√©m termos formais: {possui_termo_formal}")


class TestRedacaoAgentReal:
    """Testes do agente de reda√ß√£o com chamadas reais"""

    @pytest.fixture
    def redacao_agent(self):
        """Inicializa o agente de reda√ß√£o"""
        from lib.agents.redacao import RedacaoAgent

        return RedacaoAgent()

    @pytest.mark.asyncio
    async def test_gerar_peticao_inicial_real(self, redacao_agent):
        """Testa gera√ß√£o de peti√ß√£o inicial completa"""
        task = """
        Elabore uma peti√ß√£o inicial de cobran√ßa de d√≠vida no valor de R$ 15.000,00.

        DADOS:
        - Autor: Jo√£o da Silva, CPF 123.456.789-00, residente em Divin√≥polis/MG
        - R√©u: Maria de Souza, CPF 987.654.321-00, residente em Belo Horizonte/MG
        - D√≠vida: Contrato de empr√©stimo particular datado de 01/01/2024
        - Valor: R$ 15.000,00 com juros de 1% ao m√™s
        - Vencimento: 01/06/2024
        """

        context = {"tipo": "peticao_inicial", "vara": "Vara C√≠vel de Divin√≥polis/MG"}

        resultado = await redacao_agent.execute(task, context)

        # Verifica√ß√µes
        assert (
            resultado["status"] == "completed"
        ), f"Falha: {resultado.get('error', 'Erro desconhecido')}"
        assert resultado["response"], "Deve ter resposta"
        assert len(resultado["response"]) > 200, "Peti√ß√£o deve ser substancial"

        # Verificar elementos t√≠picos de peti√ß√£o
        response_lower = resultado["response"].lower()
        assert any(
            termo in response_lower for termo in ["excelent√≠ssimo", "exmo", "mm"]
        ), "Deve ter vocativo"

        print(f"‚úÖ Peti√ß√£o inicial gerada com {len(resultado['response'])} caracteres")
        print(f"   Confian√ßa: {resultado.get('confidence', 'N/A')}")
        print(f"   Valida√ß√£o: {resultado.get('metadata', {}).get('validacao', 'N/A')}")

    @pytest.mark.asyncio
    async def test_gerar_contestacao_real(self, redacao_agent):
        """Testa gera√ß√£o de contesta√ß√£o"""
        task = """
        Elabore uma contesta√ß√£o para a√ß√£o de cobran√ßa indevida.

        CONTEXTO:
        - O r√©u est√° sendo cobrado por uma d√≠vida que j√° foi paga
        - Possui comprovante de pagamento (recibo banc√°rio)
        - Pede danos morais por cobran√ßa indevida
        """

        context = {"tipo": "contestacao"}

        resultado = await redacao_agent.execute(task, context)

        assert resultado["status"] == "completed"
        assert len(resultado["response"]) > 200
        print(f"‚úÖ Contesta√ß√£o gerada com {len(resultado['response'])} caracteres")

    @pytest.mark.asyncio
    async def test_gerar_recurso_real(self, redacao_agent):
        """Testa gera√ß√£o de recurso de apela√ß√£o"""
        task = """
        Elabore um recurso de apela√ß√£o contra senten√ßa que julgou improcedente a√ß√£o de
        indeniza√ß√£o por danos morais.

        MOTIVOS:
        - Senten√ßa n√£o considerou todas as provas produzidas
        - Erro na valora√ß√£o dos depoimentos testemunhais
        - Jurisprud√™ncia favor√°vel ao autor
        """

        context = {"tipo": "recurso"}

        resultado = await redacao_agent.execute(task, context)

        assert resultado["status"] == "completed"
        assert len(resultado["response"]) > 200
        print(f"‚úÖ Recurso gerado com {len(resultado['response'])} caracteres")


class TestWorkflowMinutaCompleto:
    """Testa o workflow completo de cria√ß√£o e edi√ß√£o de minuta"""

    @pytest.mark.asyncio
    async def test_workflow_criar_editar_minuta(self):
        """Testa workflow: criar -> expandir -> revisar -> formalizar"""
        from lib.agents.redacao import RedacaoAgent
        from lib.ai_commands import AIMinutaCommands

        ai_commands = AIMinutaCommands()
        redacao_agent = RedacaoAgent()

        # 1. Criar rascunho inicial com agente
        print("\nüìù ETAPA 1: Criando rascunho inicial...")
        resultado_inicial = await redacao_agent.execute(
            "Elabore um contrato de presta√ß√£o de servi√ßos advocat√≠cios",
            {"tipo": "contrato"},
        )

        assert resultado_inicial["status"] == "completed"
        texto_v1 = resultado_inicial["response"]
        print(f"   ‚úÖ Rascunho criado: {len(texto_v1)} caracteres")

        # 2. Expandir uma se√ß√£o (simular sele√ß√£o de trecho)
        print("\nüìù ETAPA 2: Expandindo se√ß√£o de honor√°rios...")
        trecho = (
            "Os honor√°rios advocat√≠cios ser√£o pagos conforme acordado entre as partes."
        )

        texto_expandido = ""
        async for chunk in ai_commands.expandir(trecho):
            texto_expandido += chunk

        print(
            f"   ‚úÖ Se√ß√£o expandida: {len(trecho)} -> {len(texto_expandido)} caracteres"
        )

        # 3. Revisar o documento
        print("\nüìù ETAPA 3: Revisando documento completo...")

        # Pegar primeiros 500 chars para teste r√°pido
        texto_para_revisao = texto_v1[:500] if len(texto_v1) > 500 else texto_v1

        texto_revisado = ""
        async for chunk in ai_commands.revisar(texto_para_revisao):
            texto_revisado += chunk

        print(f"   ‚úÖ Documento revisado: {len(texto_revisado)} caracteres")

        # 4. Verificar resultado final
        print("\n‚úÖ WORKFLOW COMPLETO EXECUTADO COM SUCESSO!")
        print(f"   - Rascunho inicial: {len(texto_v1)} chars")
        print(f"   - Se√ß√£o expandida: {len(texto_expandido)} chars")
        print(f"   - Documento revisado: {len(texto_revisado)} chars")

        assert len(texto_v1) > 100
        assert len(texto_expandido) > len(trecho)
        assert len(texto_revisado) > 50


class TestMinutasIntegracaoJustine:
    """Testa integra√ß√£o de minutas com agente Justine (monitoramento DJEN)"""

    @pytest.mark.asyncio
    async def test_gerar_minuta_baseada_em_publicacao(self):
        """Testa gera√ß√£o de minuta baseada em publica√ß√£o do DJEN"""
        from lib.agents.redacao import RedacaoAgent

        redacao_agent = RedacaoAgent()

        # Simular dados de publica√ß√£o DJEN (como os retornados na sua consulta)
        publicacao = {
            "numero_processo": "5013310-29.2021.8.13.0223",
            "nomeClasse": "CUMPRIMENTO DE SENTEN√áA",
            "texto": """
            Presentes os pressupostos processuais e requisitos legais, defere-se o
            processamento do cumprimento de senten√ßa proposto pela parte autora.
            O executado dever√° ser intimado para pagar o d√©bito no prazo de 15 dias,
            sob pena de multa de 10% e honor√°rios de 10%.
            """,
            "valor": "R$ 13.001,86",
        }

        # Gerar peti√ß√£o de cumprimento de senten√ßa
        task = f"""
        Com base na seguinte decis√£o judicial, elabore uma peti√ß√£o de cumprimento de senten√ßa:

        PROCESSO: {publicacao['numero_processo']}
        CLASSE: {publicacao['nomeClasse']}
        VALOR: {publicacao['valor']}

        DECIS√ÉO:
        {publicacao['texto']}

        Elabore a peti√ß√£o inicial de cumprimento de senten√ßa requerendo a intima√ß√£o do
        executado para pagamento no prazo legal.
        """

        resultado = await redacao_agent.execute(task, {"tipo": "cumprimento_sentenca"})

        assert resultado["status"] == "completed"
        assert len(resultado["response"]) > 200

        # Verificar elementos espec√≠ficos
        response_lower = resultado["response"].lower()
        assert any(
            termo in response_lower
            for termo in ["cumprimento", "execu√ß√£o", "executado"]
        ), "Deve mencionar termos de cumprimento de senten√ßa"

        print(
            f"‚úÖ Minuta de cumprimento gerada com {len(resultado['response'])} caracteres"
        )
        print(f"   Baseada no processo: {publicacao['numero_processo']}")


if __name__ == "__main__":
    # Rodar testes
    pytest.main([__file__, "-v", "-s", "--asyncio-mode=auto"])
